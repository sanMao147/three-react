import{EventDispatcher as t,Vector3 as e,MOUSE as n,TOUCH as i,Quaternion as s,Spherical as r,Vector2 as o,BufferGeometry as a,BufferAttribute as c,TrianglesDrawMode as l,TriangleFanDrawMode as h,TriangleStripDrawMode as u,Loader as d,LoaderUtils as p,FileLoader as m,Color as f,SpotLight as g,PointLight as v,DirectionalLight as _,MeshBasicMaterial as A,sRGBEncoding as w,MeshPhysicalMaterial as x,Matrix4 as S,InstancedMesh as y,Object3D as T,TextureLoader as b,ImageBitmapLoader as L,InterleavedBuffer as E,InterleavedBufferAttribute as M,LinearFilter as R,LinearMipmapLinearFilter as I,RepeatWrapping as C,PointsMaterial as P,Material as D,LineBasicMaterial as O,MeshStandardMaterial as N,DoubleSide as k,PropertyBinding as F,SkinnedMesh as U,Mesh as H,LineSegments as B,Line as j,LineLoop as z,Points as G,Group as K,PerspectiveCamera as V,MathUtils as X,OrthographicCamera as W,Skeleton as Y,InterpolateLinear as q,AnimationClip as Z,Bone as Q,NearestFilter as J,NearestMipmapNearestFilter as $,LinearMipmapNearestFilter as tt,NearestMipmapLinearFilter as et,ClampToEdgeWrapping as nt,MirroredRepeatWrapping as it,InterpolateDiscrete as st,FrontSide as rt,Texture as ot,VectorKeyframeTrack as at,QuaternionKeyframeTrack as ct,NumberKeyframeTrack as lt,Box3 as ht,Sphere as ut,Interpolant as dt,FramebufferTexture as pt,RGBAFormat as mt,RawShaderMaterial as ft,AdditiveBlending as gt,Box2 as vt,Vector4 as _t,ShaderMaterial as At,UniformsUtils as wt,BackSide as xt,BoxGeometry as St,Plane as yt,WebGLRenderTarget as Tt,UniformsLib as bt,ShaderChunk as Lt,Box3Helper as Et,PlaneGeometry as Mt,SphericalHarmonics3 as Rt,LightProbe as It,LinearEncoding as Ct}from"three";var Pt=function(){this._tweens={},this._tweensAddedDuringUpdate={}};Pt.prototype={getAll:function(){return Object.keys(this._tweens).map(function(t){return this._tweens[t]}.bind(this))},removeAll:function(){this._tweens={}},add:function(t){this._tweens[t.getId()]=t,this._tweensAddedDuringUpdate[t.getId()]=t},remove:function(t){delete this._tweens[t.getId()],delete this._tweensAddedDuringUpdate[t.getId()]},update:function(t,e){var n=Object.keys(this._tweens);if(0===n.length)return!1;for(t=void 0!==t?t:Nt.now();0<n.length;){this._tweensAddedDuringUpdate={};for(var i=0;i<n.length;i++){var s=this._tweens[n[i]];s&&!1===s.update(t)&&(s._isPlaying=!1,e||delete this._tweens[n[i]])}n=Object.keys(this._tweensAddedDuringUpdate)}return!0}};var Dt,Ot,Nt=new Pt;Nt.Group=Pt,Nt._nextId=0,Nt.nextId=function(){return Nt._nextId++},"undefined"==typeof self&&"undefined"!=typeof process&&process.hrtime?Nt.now=function(){var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:"undefined"!=typeof self&&void 0!==self.performance&&void 0!==self.performance.now?Nt.now=self.performance.now.bind(self.performance):void 0!==Date.now?Nt.now=Date.now:Nt.now=function(){return(new Date).getTime()},Nt.Tween=function(t,e){this._object=t,this._valuesStart={},this._valuesEnd={},this._valuesStartRepeat={},this._duration=1e3,this._repeat=0,this._repeatDelayTime=void 0,this._yoyo=!1,this._isPlaying=!1,this._reversed=!1,this._delayTime=0,this._startTime=null,this._easingFunction=Nt.Easing.Linear.None,this._interpolationFunction=Nt.Interpolation.Linear,this._chainedTweens=[],this._onStartCallback=null,this._onStartCallbackFired=!1,this._onUpdateCallback=null,this._onCompleteCallback=null,this._onStopCallback=null,this._group=e||Nt,this._id=Nt.nextId()},Nt.Tween.prototype={getId:function(){return this._id},isPlaying:function(){return this._isPlaying},to:function(t,e){return this._valuesEnd=Object.create(t),void 0!==e&&(this._duration=e),this},duration:function(t){return this._duration=t,this},start:function(t){for(var e in this._group.add(this),this._isPlaying=!0,this._onStartCallbackFired=!1,this._startTime=void 0!==t?"string"==typeof t?Nt.now()+parseFloat(t):t:Nt.now(),this._startTime+=this._delayTime,this._valuesEnd){if(this._valuesEnd[e]instanceof Array){if(0===this._valuesEnd[e].length)continue;this._valuesEnd[e]=[this._object[e]].concat(this._valuesEnd[e])}void 0!==this._object[e]&&(this._valuesStart[e]=this._object[e],this._valuesStart[e]instanceof Array==0&&(this._valuesStart[e]*=1),this._valuesStartRepeat[e]=this._valuesStart[e]||0)}return this},stop:function(){return this._isPlaying&&(this._group.remove(this),this._isPlaying=!1,null!==this._onStopCallback&&this._onStopCallback(this._object),this.stopChainedTweens()),this},end:function(){return this.update(1/0),this},stopChainedTweens:function(){for(var t=0,e=this._chainedTweens.length;t<e;t++)this._chainedTweens[t].stop()},group:function(t){return this._group=t,this},delay:function(t){return this._delayTime=t,this},repeat:function(t){return this._repeat=t,this},repeatDelay:function(t){return this._repeatDelayTime=t,this},yoyo:function(t){return this._yoyo=t,this},easing:function(t){return this._easingFunction=t,this},interpolation:function(t){return this._interpolationFunction=t,this},chain:function(){return this._chainedTweens=arguments,this},onStart:function(t){return this._onStartCallback=t,this},onUpdate:function(t){return this._onUpdateCallback=t,this},onComplete:function(t){return this._onCompleteCallback=t,this},onStop:function(t){return this._onStopCallback=t,this},update:function(t){var e,n,i;if(t<this._startTime)return!0;for(e in!1===this._onStartCallbackFired&&(null!==this._onStartCallback&&this._onStartCallback(this._object),this._onStartCallbackFired=!0),n=(t-this._startTime)/this._duration,n=0===this._duration||1<n?1:n,i=this._easingFunction(n),this._valuesEnd)if(void 0!==this._valuesStart[e]){var s=this._valuesStart[e]||0,r=this._valuesEnd[e];r instanceof Array?this._object[e]=this._interpolationFunction(r,i):("string"==typeof r&&(r="+"===r.charAt(0)||"-"===r.charAt(0)?s+parseFloat(r):parseFloat(r)),"number"==typeof r&&(this._object[e]=s+(r-s)*i))}if(null!==this._onUpdateCallback&&this._onUpdateCallback(this._object),1!==n)return!0;if(0<this._repeat){for(e in isFinite(this._repeat)&&this._repeat--,this._valuesStartRepeat){if("string"==typeof this._valuesEnd[e]&&(this._valuesStartRepeat[e]=this._valuesStartRepeat[e]+parseFloat(this._valuesEnd[e])),this._yoyo){var o=this._valuesStartRepeat[e];this._valuesStartRepeat[e]=this._valuesEnd[e],this._valuesEnd[e]=o}this._valuesStart[e]=this._valuesStartRepeat[e]}return this._yoyo&&(this._reversed=!this._reversed),void 0!==this._repeatDelayTime?this._startTime=t+this._repeatDelayTime:this._startTime=t+this._delayTime,!0}null!==this._onCompleteCallback&&this._onCompleteCallback(this._object);for(var a=0,c=this._chainedTweens.length;a<c;a++)this._chainedTweens[a].start(this._startTime+this._duration);return!1}},Nt.Easing={Linear:{None:function(t){return t}},Quadratic:{In:function(t){return t*t},Out:function(t){return t*(2-t)},InOut:function(t){return(t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)}},Cubic:{In:function(t){return t*t*t},Out:function(t){return--t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t:.5*((t-=2)*t*t+2)}},Quartic:{In:function(t){return t*t*t*t},Out:function(t){return 1- --t*t*t*t},InOut:function(t){return(t*=2)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)}},Quintic:{In:function(t){return t*t*t*t*t},Out:function(t){return--t*t*t*t*t+1},InOut:function(t){return(t*=2)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)}},Sinusoidal:{In:function(t){return 1-Math.cos(t*Math.PI/2)},Out:function(t){return Math.sin(t*Math.PI/2)},InOut:function(t){return.5*(1-Math.cos(Math.PI*t))}},Exponential:{In:function(t){return 0===t?0:Math.pow(1024,t-1)},Out:function(t){return 1===t?1:1-Math.pow(2,-10*t)},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?.5*Math.pow(1024,t-1):.5*(2-Math.pow(2,-10*(t-1)))}},Circular:{In:function(t){return 1-Math.sqrt(1-t*t)},Out:function(t){return Math.sqrt(1- --t*t)},InOut:function(t){return(t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)}},Elastic:{In:function(t){return 0===t?0:1===t?1:-Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)},Out:function(t){return 0===t?0:1===t?1:Math.pow(2,-10*t)*Math.sin(5*(t-.1)*Math.PI)+1},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?-.5*Math.pow(2,10*(t-1))*Math.sin(5*(t-1.1)*Math.PI):.5*Math.pow(2,-10*(t-1))*Math.sin(5*(t-1.1)*Math.PI)+1}},Back:{In:function(t){return t*t*(2.70158*t-1.70158)},Out:function(t){return--t*t*(2.70158*t+1.70158)+1},InOut:function(t){var e=2.5949095;return(t*=2)<1?t*t*((1+e)*t-e)*.5:.5*((t-=2)*t*((1+e)*t+e)+2)}},Bounce:{In:function(t){return 1-Nt.Easing.Bounce.Out(1-t)},Out:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},InOut:function(t){return t<.5?.5*Nt.Easing.Bounce.In(2*t):.5*Nt.Easing.Bounce.Out(2*t-1)+.5}}},Nt.Interpolation={Linear:function(t,e){var n=t.length-1,i=n*e,s=Math.floor(i),r=Nt.Interpolation.Utils.Linear;return e<0?r(t[0],t[1],i):1<e?r(t[n],t[n-1],n-i):r(t[s],t[n<s+1?n:s+1],i-s)},Bezier:function(t,e){for(var n=0,i=t.length-1,s=Math.pow,r=Nt.Interpolation.Utils.Bernstein,o=0;o<=i;o++)n+=s(1-e,i-o)*s(e,o)*t[o]*r(i,o);return n},CatmullRom:function(t,e){var n=t.length-1,i=n*e,s=Math.floor(i),r=Nt.Interpolation.Utils.CatmullRom;return t[0]===t[n]?(e<0&&(s=Math.floor(i=n*(1+e))),r(t[(s-1+n)%n],t[s],t[(s+1)%n],t[(s+2)%n],i-s)):e<0?t[0]-(r(t[0],t[0],t[1],t[1],-i)-t[0]):1<e?t[n]-(r(t[n],t[n],t[n-1],t[n-1],i-n)-t[n]):r(t[s?s-1:0],t[s],t[n<s+1?n:s+1],t[n<s+2?n:s+2],i-s)},Utils:{Linear:function(t,e,n){return(e-t)*n+t},Bernstein:function(t,e){var n=Nt.Interpolation.Utils.Factorial;return n(t)/n(e)/n(t-e)},Factorial:(Ot=[1],function(t){var e=1;if(Ot[t])return Ot[t];for(var n=t;1<n;n--)e*=n;return Ot[t]=e}),CatmullRom:function(t,e,n,i,s){var r=.5*(n-t),o=.5*(i-e),a=s*s;return(2*e-2*n+r+o)*(s*a)+(-3*e+3*n-2*r-o)*a+r*s+e}}},Dt=globalThis,"function"==typeof define&&define.amd?define([],(function(){return Nt})):"undefined"!=typeof module&&"object"==typeof exports?module.exports=Nt:void 0!==Dt&&(Dt.TWEEN=Nt);const kt={type:"change"},Ft={type:"start"},Ut={type:"end"};class Ht extends t{constructor(t,a){super(),this.object=t,this.domElement=a,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new e,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:n.ROTATE,MIDDLE:n.DOLLY,RIGHT:n.PAN},this.touches={ONE:i.ROTATE,TWO:i.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return d.phi},this.getAzimuthalAngle=function(){return d.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(t){t.addEventListener("keydown",q),this._domElementKeyEvents=t},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",q),this._domElementKeyEvents=null},this.saveState=function(){c.target0.copy(c.target),c.position0.copy(c.object.position),c.zoom0=c.object.zoom},this.reset=function(){c.target.copy(c.target0),c.object.position.copy(c.position0),c.object.zoom=c.zoom0,c.object.updateProjectionMatrix(),c.dispatchEvent(kt),c.update(),h=l.NONE},this.update=function(){const n=new e,i=(new s).setFromUnitVectors(t.up,new e(0,1,0)),r=i.clone().invert(),o=new e,a=new s,v=2*Math.PI;return function(){const t=c.object.position;n.copy(t).sub(c.target),n.applyQuaternion(i),d.setFromVector3(n),c.autoRotate&&h===l.NONE&&R(2*Math.PI/60/60*c.autoRotateSpeed),c.enableDamping?(d.theta+=p.theta*c.dampingFactor,d.phi+=p.phi*c.dampingFactor):(d.theta+=p.theta,d.phi+=p.phi);let e=c.minAzimuthAngle,s=c.maxAzimuthAngle;return isFinite(e)&&isFinite(s)&&(e<-Math.PI?e+=v:e>Math.PI&&(e-=v),s<-Math.PI?s+=v:s>Math.PI&&(s-=v),d.theta=e<=s?Math.max(e,Math.min(s,d.theta)):d.theta>(e+s)/2?Math.max(e,d.theta):Math.min(s,d.theta)),d.phi=Math.max(c.minPolarAngle,Math.min(c.maxPolarAngle,d.phi)),d.makeSafe(),d.radius*=m,d.radius=Math.max(c.minDistance,Math.min(c.maxDistance,d.radius)),!0===c.enableDamping?c.target.addScaledVector(f,c.dampingFactor):c.target.add(f),n.setFromSpherical(d),n.applyQuaternion(r),t.copy(c.target).add(n),c.object.lookAt(c.target),!0===c.enableDamping?(p.theta*=1-c.dampingFactor,p.phi*=1-c.dampingFactor,f.multiplyScalar(1-c.dampingFactor)):(p.set(0,0,0),f.set(0,0,0)),m=1,!!(g||o.distanceToSquared(c.object.position)>u||8*(1-a.dot(c.object.quaternion))>u)&&(c.dispatchEvent(kt),o.copy(c.object.position),a.copy(c.object.quaternion),g=!1,!0)}}(),this.dispose=function(){c.domElement.removeEventListener("contextmenu",Z),c.domElement.removeEventListener("pointerdown",K),c.domElement.removeEventListener("pointercancel",W),c.domElement.removeEventListener("wheel",Y),c.domElement.removeEventListener("pointermove",V),c.domElement.removeEventListener("pointerup",X),null!==c._domElementKeyEvents&&(c._domElementKeyEvents.removeEventListener("keydown",q),c._domElementKeyEvents=null)};const c=this,l={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let h=l.NONE;const u=1e-6,d=new r,p=new r;let m=1;const f=new e;let g=!1;const v=new o,_=new o,A=new o,w=new o,x=new o,S=new o,y=new o,T=new o,b=new o,L=[],E={};function M(){return Math.pow(.95,c.zoomSpeed)}function R(t){p.theta-=t}function I(t){p.phi-=t}const C=function(){const t=new e;return function(e,n){t.setFromMatrixColumn(n,0),t.multiplyScalar(-e),f.add(t)}}(),P=function(){const t=new e;return function(e,n){!0===c.screenSpacePanning?t.setFromMatrixColumn(n,1):(t.setFromMatrixColumn(n,0),t.crossVectors(c.object.up,t)),t.multiplyScalar(e),f.add(t)}}(),D=function(){const t=new e;return function(e,n){const i=c.domElement;if(c.object.isPerspectiveCamera){const s=c.object.position;t.copy(s).sub(c.target);let r=t.length();r*=Math.tan(c.object.fov/2*Math.PI/180),C(2*e*r/i.clientHeight,c.object.matrix),P(2*n*r/i.clientHeight,c.object.matrix)}else c.object.isOrthographicCamera?(C(e*(c.object.right-c.object.left)/c.object.zoom/i.clientWidth,c.object.matrix),P(n*(c.object.top-c.object.bottom)/c.object.zoom/i.clientHeight,c.object.matrix)):c.enablePan=!1}}();function O(t){c.object.isPerspectiveCamera?m/=t:c.object.isOrthographicCamera?(c.object.zoom=Math.max(c.minZoom,Math.min(c.maxZoom,c.object.zoom*t)),c.object.updateProjectionMatrix(),g=!0):c.enableZoom=!1}function N(t){c.object.isPerspectiveCamera?m*=t:c.object.isOrthographicCamera?(c.object.zoom=Math.max(c.minZoom,Math.min(c.maxZoom,c.object.zoom/t)),c.object.updateProjectionMatrix(),g=!0):c.enableZoom=!1}function k(t){v.set(t.clientX,t.clientY)}function F(t){w.set(t.clientX,t.clientY)}function U(){if(1===L.length)v.set(L[0].pageX,L[0].pageY);else{const t=.5*(L[0].pageX+L[1].pageX),e=.5*(L[0].pageY+L[1].pageY);v.set(t,e)}}function H(){if(1===L.length)w.set(L[0].pageX,L[0].pageY);else{const t=.5*(L[0].pageX+L[1].pageX),e=.5*(L[0].pageY+L[1].pageY);w.set(t,e)}}function B(){const t=L[0].pageX-L[1].pageX,e=L[0].pageY-L[1].pageY,n=Math.sqrt(t*t+e*e);y.set(0,n)}function j(t){if(1==L.length)_.set(t.pageX,t.pageY);else{const e=$(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);_.set(n,i)}A.subVectors(_,v).multiplyScalar(c.rotateSpeed);const e=c.domElement;R(2*Math.PI*A.x/e.clientHeight),I(2*Math.PI*A.y/e.clientHeight),v.copy(_)}function z(t){if(1===L.length)x.set(t.pageX,t.pageY);else{const e=$(t),n=.5*(t.pageX+e.x),i=.5*(t.pageY+e.y);x.set(n,i)}S.subVectors(x,w).multiplyScalar(c.panSpeed),D(S.x,S.y),w.copy(x)}function G(t){const e=$(t),n=t.pageX-e.x,i=t.pageY-e.y,s=Math.sqrt(n*n+i*i);T.set(0,s),b.set(0,Math.pow(T.y/y.y,c.zoomSpeed)),O(b.y),y.copy(T)}function K(t){var e;!1!==c.enabled&&(0===L.length&&(c.domElement.setPointerCapture(t.pointerId),c.domElement.addEventListener("pointermove",V),c.domElement.addEventListener("pointerup",X)),e=t,L.push(e),"touch"===t.pointerType?function(t){switch(J(t),L.length){case 1:switch(c.touches.ONE){case i.ROTATE:if(!1===c.enableRotate)return;U(),h=l.TOUCH_ROTATE;break;case i.PAN:if(!1===c.enablePan)return;H(),h=l.TOUCH_PAN;break;default:h=l.NONE}break;case 2:switch(c.touches.TWO){case i.DOLLY_PAN:if(!1===c.enableZoom&&!1===c.enablePan)return;c.enableZoom&&B(),c.enablePan&&H(),h=l.TOUCH_DOLLY_PAN;break;case i.DOLLY_ROTATE:if(!1===c.enableZoom&&!1===c.enableRotate)return;c.enableZoom&&B(),c.enableRotate&&U(),h=l.TOUCH_DOLLY_ROTATE;break;default:h=l.NONE}break;default:h=l.NONE}h!==l.NONE&&c.dispatchEvent(Ft)}(t):function(t){let e;switch(t.button){case 0:e=c.mouseButtons.LEFT;break;case 1:e=c.mouseButtons.MIDDLE;break;case 2:e=c.mouseButtons.RIGHT;break;default:e=-1}switch(e){case n.DOLLY:if(!1===c.enableZoom)return;i=t,y.set(i.clientX,i.clientY),h=l.DOLLY;break;case n.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===c.enablePan)return;F(t),h=l.PAN}else{if(!1===c.enableRotate)return;k(t),h=l.ROTATE}break;case n.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(!1===c.enableRotate)return;k(t),h=l.ROTATE}else{if(!1===c.enablePan)return;F(t),h=l.PAN}break;default:h=l.NONE}var i;h!==l.NONE&&c.dispatchEvent(Ft)}(t))}function V(t){!1!==c.enabled&&("touch"===t.pointerType?function(t){switch(J(t),h){case l.TOUCH_ROTATE:if(!1===c.enableRotate)return;j(t),c.update();break;case l.TOUCH_PAN:if(!1===c.enablePan)return;z(t),c.update();break;case l.TOUCH_DOLLY_PAN:if(!1===c.enableZoom&&!1===c.enablePan)return;e=t,c.enableZoom&&G(e),c.enablePan&&z(e),c.update();break;case l.TOUCH_DOLLY_ROTATE:if(!1===c.enableZoom&&!1===c.enableRotate)return;!function(t){c.enableZoom&&G(t),c.enableRotate&&j(t)}(t),c.update();break;default:h=l.NONE}var e}(t):function(t){switch(h){case l.ROTATE:if(!1===c.enableRotate)return;!function(t){_.set(t.clientX,t.clientY),A.subVectors(_,v).multiplyScalar(c.rotateSpeed);const e=c.domElement;R(2*Math.PI*A.x/e.clientHeight),I(2*Math.PI*A.y/e.clientHeight),v.copy(_),c.update()}(t);break;case l.DOLLY:if(!1===c.enableZoom)return;e=t,T.set(e.clientX,e.clientY),b.subVectors(T,y),b.y>0?O(M()):b.y<0&&N(M()),y.copy(T),c.update();break;case l.PAN:if(!1===c.enablePan)return;!function(t){x.set(t.clientX,t.clientY),S.subVectors(x,w).multiplyScalar(c.panSpeed),D(S.x,S.y),w.copy(x),c.update()}(t)}var e}(t))}function X(t){Q(t),0===L.length&&(c.domElement.releasePointerCapture(t.pointerId),c.domElement.removeEventListener("pointermove",V),c.domElement.removeEventListener("pointerup",X)),c.dispatchEvent(Ut),h=l.NONE}function W(t){Q(t)}function Y(t){var e;!1!==c.enabled&&!1!==c.enableZoom&&h===l.NONE&&(t.preventDefault(),c.dispatchEvent(Ft),(e=t).deltaY<0?N(M()):e.deltaY>0&&O(M()),c.update(),c.dispatchEvent(Ut))}function q(t){!1!==c.enabled&&!1!==c.enablePan&&function(t){let e=!1;switch(t.code){case c.keys.UP:t.ctrlKey||t.metaKey||t.shiftKey?I(2*Math.PI*c.rotateSpeed/c.domElement.clientHeight):D(0,c.keyPanSpeed),e=!0;break;case c.keys.BOTTOM:t.ctrlKey||t.metaKey||t.shiftKey?I(-2*Math.PI*c.rotateSpeed/c.domElement.clientHeight):D(0,-c.keyPanSpeed),e=!0;break;case c.keys.LEFT:t.ctrlKey||t.metaKey||t.shiftKey?R(2*Math.PI*c.rotateSpeed/c.domElement.clientHeight):D(c.keyPanSpeed,0),e=!0;break;case c.keys.RIGHT:t.ctrlKey||t.metaKey||t.shiftKey?R(-2*Math.PI*c.rotateSpeed/c.domElement.clientHeight):D(-c.keyPanSpeed,0),e=!0}e&&(t.preventDefault(),c.update())}(t)}function Z(t){!1!==c.enabled&&t.preventDefault()}function Q(t){delete E[t.pointerId];for(let e=0;e<L.length;e++)if(L[e].pointerId==t.pointerId)return void L.splice(e,1)}function J(t){let e=E[t.pointerId];void 0===e&&(e=new o,E[t.pointerId]=e),e.set(t.pageX,t.pageY)}function $(t){const e=t.pointerId===L[0].pointerId?L[1]:L[0];return E[e.pointerId]}c.domElement.addEventListener("contextmenu",Z),c.domElement.addEventListener("pointerdown",K),c.domElement.addEventListener("pointercancel",W),c.domElement.addEventListener("wheel",Y,{passive:!1}),this.update()}}function Bt(t,e=!1){const n=null!==t[0].index,i=new Set(Object.keys(t[0].attributes)),s=new Set(Object.keys(t[0].morphAttributes)),r={},o={},c=t[0].morphTargetsRelative,l=new a;let h=0;for(let a=0;a<t.length;++a){const u=t[a];let d=0;if(n!==(null!==u.index))return null;for(const t in u.attributes){if(!i.has(t))return null;void 0===r[t]&&(r[t]=[]),r[t].push(u.attributes[t]),d++}if(d!==i.size)return null;if(c!==u.morphTargetsRelative)return null;for(const t in u.morphAttributes){if(!s.has(t))return null;void 0===o[t]&&(o[t]=[]),o[t].push(u.morphAttributes[t])}if(e){let t;if(n)t=u.index.count;else{if(void 0===u.attributes.position)return null;t=u.attributes.position.count}l.addGroup(h,t,a),h+=t}}if(n){let e=0;const n=[];for(let i=0;i<t.length;++i){const s=t[i].index;for(let t=0;t<s.count;++t)n.push(s.getX(t)+e);e+=t[i].attributes.position.count}l.setIndex(n)}for(const a in r){const t=jt(r[a]);if(!t)return null;l.setAttribute(a,t)}for(const a in o){const t=o[a][0].length;if(0===t)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[a]=[];for(let e=0;e<t;++e){const t=[];for(let i=0;i<o[a].length;++i)t.push(o[a][i][e]);const n=jt(t);if(!n)return null;l.morphAttributes[a].push(n)}}return l}function jt(t){let e,n,i,s=0;for(let a=0;a<t.length;++a){const r=t[a];if(r.isInterleavedBufferAttribute)return null;if(void 0===e&&(e=r.array.constructor),e!==r.array.constructor)return null;if(void 0===n&&(n=r.itemSize),n!==r.itemSize)return null;if(void 0===i&&(i=r.normalized),i!==r.normalized)return null;s+=r.array.length}const r=new e(s);let o=0;for(let a=0;a<t.length;++a)r.set(t[a].array,o),o+=t[a].array.length;return new c(r,n,i)}function zt(t,e){if(e===l)return t;if(e===h||e===u){let n=t.getIndex();if(null===n){const e=[],i=t.getAttribute("position");if(void 0===i)return t;for(let t=0;t<i.count;t++)e.push(t);t.setIndex(e),n=t.getIndex()}const i=n.count-2,s=[];if(e===h)for(let t=1;t<=i;t++)s.push(n.getX(0)),s.push(n.getX(t)),s.push(n.getX(t+1));else for(let t=0;t<i;t++)t%2==0?(s.push(n.getX(t)),s.push(n.getX(t+1)),s.push(n.getX(t+2))):(s.push(n.getX(t+2)),s.push(n.getX(t+1)),s.push(n.getX(t)));s.length;const r=t.clone();return r.setIndex(s),r.clearGroups(),r}return t}class Gt extends d{constructor(t){super(t),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register((function(t){return new qt(t)})),this.register((function(t){return new ne(t)})),this.register((function(t){return new ie(t)})),this.register((function(t){return new se(t)})),this.register((function(t){return new Qt(t)})),this.register((function(t){return new Jt(t)})),this.register((function(t){return new $t(t)})),this.register((function(t){return new te(t)})),this.register((function(t){return new Yt(t)})),this.register((function(t){return new ee(t)})),this.register((function(t){return new Zt(t)})),this.register((function(t){return new Xt(t)})),this.register((function(t){return new re(t)})),this.register((function(t){return new oe(t)}))}load(t,e,n,i){const s=this;let r;r=""!==this.resourcePath?this.resourcePath:""!==this.path?this.path:p.extractUrlBase(t),this.manager.itemStart(t);const o=function(e){i&&i(e),s.manager.itemError(t),s.manager.itemEnd(t)},a=new m(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(t,(function(n){try{s.parse(n,r,(function(n){e(n),s.manager.itemEnd(t)}),o)}catch(i){o(i)}}),n,o)}setDRACOLoader(t){return this.dracoLoader=t,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(t){return this.ktx2Loader=t,this}setMeshoptDecoder(t){return this.meshoptDecoder=t,this}register(t){return-1===this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.push(t),this}unregister(t){return-1!==this.pluginCallbacks.indexOf(t)&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t),1),this}parse(t,e,n,i){let s;const r={},o={},a=new TextDecoder;if("string"==typeof t)s=JSON.parse(t);else if(t instanceof ArrayBuffer)if(a.decode(new Uint8Array(t,0,4))===ae){try{r[Vt.KHR_BINARY_GLTF]=new ce(t)}catch(l){return void(i&&i(l))}s=JSON.parse(r[Vt.KHR_BINARY_GLTF].content)}else s=JSON.parse(a.decode(t));else s=t;if(void 0===s.asset||s.asset.version[0]<2)return void(i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));const c=new Ie(s,{path:e||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const t=this.pluginCallbacks[h](c);o[t.name]=t,r[t.name]=!0}if(s.extensionsUsed)for(let h=0;h<s.extensionsUsed.length;++h){const t=s.extensionsUsed[h],e=s.extensionsRequired||[];switch(t){case Vt.KHR_MATERIALS_UNLIT:r[t]=new Wt;break;case Vt.KHR_DRACO_MESH_COMPRESSION:r[t]=new le(s,this.dracoLoader);break;case Vt.KHR_TEXTURE_TRANSFORM:r[t]=new he;break;case Vt.KHR_MESH_QUANTIZATION:r[t]=new ue;break;default:e.indexOf(t)>=0&&o[t]}}c.setExtensions(r),c.setPlugins(o),c.parse(n,i)}parseAsync(t,e){const n=this;return new Promise((function(i,s){n.parse(t,e,i,s)}))}}function Kt(){let t={};return{get:function(e){return t[e]},add:function(e,n){t[e]=n},remove:function(e){delete t[e]},removeAll:function(){t={}}}}const Vt={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Xt{constructor(t){this.parser=t,this.name=Vt.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const t=this.parser,e=this.parser.json.nodes||[];for(let n=0,i=e.length;n<i;n++){const i=e[n];i.extensions&&i.extensions[this.name]&&void 0!==i.extensions[this.name].light&&t._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(t){const e=this.parser,n="light:"+t;let i=e.cache.get(n);if(i)return i;const s=e.json,r=((s.extensions&&s.extensions[this.name]||{}).lights||[])[t];let o;const a=new f(16777215);void 0!==r.color&&a.fromArray(r.color);const c=void 0!==r.range?r.range:0;switch(r.type){case"directional":o=new _(a),o.target.position.set(0,0,-1),o.add(o.target);break;case"point":o=new v(a),o.distance=c;break;case"spot":o=new g(a),o.distance=c,r.spot=r.spot||{},r.spot.innerConeAngle=void 0!==r.spot.innerConeAngle?r.spot.innerConeAngle:0,r.spot.outerConeAngle=void 0!==r.spot.outerConeAngle?r.spot.outerConeAngle:Math.PI/4,o.angle=r.spot.outerConeAngle,o.penumbra=1-r.spot.innerConeAngle/r.spot.outerConeAngle,o.target.position.set(0,0,-1),o.add(o.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+r.type)}return o.position.set(0,0,0),o.decay=2,Te(o,r),void 0!==r.intensity&&(o.intensity=r.intensity),o.name=e.createUniqueName(r.name||"light_"+t),i=Promise.resolve(o),e.cache.add(n,i),i}getDependency(t,e){if("light"===t)return this._loadLight(e)}createNodeAttachment(t){const e=this,n=this.parser,i=n.json.nodes[t],s=(i.extensions&&i.extensions[this.name]||{}).light;return void 0===s?null:this._loadLight(s).then((function(t){return n._getNodeRef(e.cache,s,t)}))}}class Wt{constructor(){this.name=Vt.KHR_MATERIALS_UNLIT}getMaterialType(){return A}extendParams(t,e,n){const i=[];t.color=new f(1,1,1),t.opacity=1;const s=e.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const e=s.baseColorFactor;t.color.fromArray(e),t.opacity=e[3]}void 0!==s.baseColorTexture&&i.push(n.assignTexture(t,"map",s.baseColorTexture,w))}return Promise.all(i)}}class Yt{constructor(t){this.parser=t,this.name=Vt.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(t,e){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name].emissiveStrength;return void 0!==i&&(e.emissiveIntensity=i),Promise.resolve()}}class qt{constructor(t){this.parser=t,this.name=Vt.KHR_MATERIALS_CLEARCOAT}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?x:null}extendMaterialParams(t,e){const n=this.parser,i=n.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],r=i.extensions[this.name];if(void 0!==r.clearcoatFactor&&(e.clearcoat=r.clearcoatFactor),void 0!==r.clearcoatTexture&&s.push(n.assignTexture(e,"clearcoatMap",r.clearcoatTexture)),void 0!==r.clearcoatRoughnessFactor&&(e.clearcoatRoughness=r.clearcoatRoughnessFactor),void 0!==r.clearcoatRoughnessTexture&&s.push(n.assignTexture(e,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),void 0!==r.clearcoatNormalTexture&&(s.push(n.assignTexture(e,"clearcoatNormalMap",r.clearcoatNormalTexture)),void 0!==r.clearcoatNormalTexture.scale)){const t=r.clearcoatNormalTexture.scale;e.clearcoatNormalScale=new o(t,t)}return Promise.all(s)}}class Zt{constructor(t){this.parser=t,this.name=Vt.KHR_MATERIALS_IRIDESCENCE}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?x:null}extendMaterialParams(t,e){const n=this.parser,i=n.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],r=i.extensions[this.name];return void 0!==r.iridescenceFactor&&(e.iridescence=r.iridescenceFactor),void 0!==r.iridescenceTexture&&s.push(n.assignTexture(e,"iridescenceMap",r.iridescenceTexture)),void 0!==r.iridescenceIor&&(e.iridescenceIOR=r.iridescenceIor),void 0===e.iridescenceThicknessRange&&(e.iridescenceThicknessRange=[100,400]),void 0!==r.iridescenceThicknessMinimum&&(e.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),void 0!==r.iridescenceThicknessMaximum&&(e.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),void 0!==r.iridescenceThicknessTexture&&s.push(n.assignTexture(e,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(s)}}class Qt{constructor(t){this.parser=t,this.name=Vt.KHR_MATERIALS_SHEEN}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?x:null}extendMaterialParams(t,e){const n=this.parser,i=n.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[];e.sheenColor=new f(0,0,0),e.sheenRoughness=0,e.sheen=1;const r=i.extensions[this.name];return void 0!==r.sheenColorFactor&&e.sheenColor.fromArray(r.sheenColorFactor),void 0!==r.sheenRoughnessFactor&&(e.sheenRoughness=r.sheenRoughnessFactor),void 0!==r.sheenColorTexture&&s.push(n.assignTexture(e,"sheenColorMap",r.sheenColorTexture,w)),void 0!==r.sheenRoughnessTexture&&s.push(n.assignTexture(e,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(s)}}class Jt{constructor(t){this.parser=t,this.name=Vt.KHR_MATERIALS_TRANSMISSION}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?x:null}extendMaterialParams(t,e){const n=this.parser,i=n.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],r=i.extensions[this.name];return void 0!==r.transmissionFactor&&(e.transmission=r.transmissionFactor),void 0!==r.transmissionTexture&&s.push(n.assignTexture(e,"transmissionMap",r.transmissionTexture)),Promise.all(s)}}class $t{constructor(t){this.parser=t,this.name=Vt.KHR_MATERIALS_VOLUME}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?x:null}extendMaterialParams(t,e){const n=this.parser,i=n.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],r=i.extensions[this.name];e.thickness=void 0!==r.thicknessFactor?r.thicknessFactor:0,void 0!==r.thicknessTexture&&s.push(n.assignTexture(e,"thicknessMap",r.thicknessTexture)),e.attenuationDistance=r.attenuationDistance||1/0;const o=r.attenuationColor||[1,1,1];return e.attenuationColor=new f(o[0],o[1],o[2]),Promise.all(s)}}class te{constructor(t){this.parser=t,this.name=Vt.KHR_MATERIALS_IOR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?x:null}extendMaterialParams(t,e){const n=this.parser.json.materials[t];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return e.ior=void 0!==i.ior?i.ior:1.5,Promise.resolve()}}class ee{constructor(t){this.parser=t,this.name=Vt.KHR_MATERIALS_SPECULAR}getMaterialType(t){const e=this.parser.json.materials[t];return e.extensions&&e.extensions[this.name]?x:null}extendMaterialParams(t,e){const n=this.parser,i=n.json.materials[t];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],r=i.extensions[this.name];e.specularIntensity=void 0!==r.specularFactor?r.specularFactor:1,void 0!==r.specularTexture&&s.push(n.assignTexture(e,"specularIntensityMap",r.specularTexture));const o=r.specularColorFactor||[1,1,1];return e.specularColor=new f(o[0],o[1],o[2]),void 0!==r.specularColorTexture&&s.push(n.assignTexture(e,"specularColorMap",r.specularColorTexture,w)),Promise.all(s)}}class ne{constructor(t){this.parser=t,this.name=Vt.KHR_TEXTURE_BASISU}loadTexture(t){const e=this.parser,n=e.json,i=n.textures[t];if(!i.extensions||!i.extensions[this.name])return null;const s=i.extensions[this.name],r=e.options.ktx2Loader;if(!r){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return e.loadTextureImage(t,s.source,r)}}class ie{constructor(t){this.parser=t,this.name=Vt.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(t){const e=this.name,n=this.parser,i=n.json,s=i.textures[t];if(!s.extensions||!s.extensions[e])return null;const r=s.extensions[e],o=i.images[r.source];let a=n.textureLoader;if(o.uri){const t=n.options.manager.getHandler(o.uri);null!==t&&(a=t)}return this.detectSupport().then((function(s){if(s)return n.loadTextureImage(t,r.source,a);if(i.extensionsRequired&&i.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(t)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(t){const e=new Image;e.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",e.onload=e.onerror=function(){t(1===e.height)}}))),this.isSupported}}class se{constructor(t){this.parser=t,this.name=Vt.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(t){const e=this.name,n=this.parser,i=n.json,s=i.textures[t];if(!s.extensions||!s.extensions[e])return null;const r=s.extensions[e],o=i.images[r.source];let a=n.textureLoader;if(o.uri){const t=n.options.manager.getHandler(o.uri);null!==t&&(a=t)}return this.detectSupport().then((function(s){if(s)return n.loadTextureImage(t,r.source,a);if(i.extensionsRequired&&i.extensionsRequired.indexOf(e)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(t)}))}detectSupport(){return this.isSupported||(this.isSupported=new Promise((function(t){const e=new Image;e.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",e.onload=e.onerror=function(){t(1===e.height)}}))),this.isSupported}}class re{constructor(t){this.name=Vt.EXT_MESHOPT_COMPRESSION,this.parser=t}loadBufferView(t){const e=this.parser.json,n=e.bufferViews[t];if(n.extensions&&n.extensions[this.name]){const t=n.extensions[this.name],i=this.parser.getDependency("buffer",t.buffer),s=this.parser.options.meshoptDecoder;if(!s||!s.supported){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then((function(e){const n=t.byteOffset||0,i=t.byteLength||0,r=t.count,o=t.byteStride,a=new Uint8Array(e,n,i);return s.decodeGltfBufferAsync?s.decodeGltfBufferAsync(r,o,a,t.mode,t.filter).then((function(t){return t.buffer})):s.ready.then((function(){const e=new ArrayBuffer(r*o);return s.decodeGltfBuffer(new Uint8Array(e),r,o,a,t.mode,t.filter),e}))}))}return null}}class oe{constructor(t){this.name=Vt.EXT_MESH_GPU_INSTANCING,this.parser=t}createNodeMesh(t){const n=this.parser.json,i=n.nodes[t];if(!i.extensions||!i.extensions[this.name]||void 0===i.mesh)return null;const r=n.meshes[i.mesh];for(const e of r.primitives)if(e.mode!==fe.TRIANGLES&&e.mode!==fe.TRIANGLE_STRIP&&e.mode!==fe.TRIANGLE_FAN&&void 0!==e.mode)return null;const o=i.extensions[this.name].attributes,a=[],c={};for(const e in o)a.push(this.parser.getDependency("accessor",o[e]).then((t=>(c[e]=t,c[e]))));return a.length<1?null:(a.push(this.parser.createNodeMesh(t)),Promise.all(a).then((t=>{const n=t.pop(),i=n.isGroup?n.children:[n],r=t[0].count,o=[];for(const a of i){const t=new S,n=new e,i=new s,l=new e(1,1,1),h=new y(a.geometry,a.material,r);for(let e=0;e<r;e++)c.TRANSLATION&&n.fromBufferAttribute(c.TRANSLATION,e),c.ROTATION&&i.fromBufferAttribute(c.ROTATION,e),c.SCALE&&l.fromBufferAttribute(c.SCALE,e),h.setMatrixAt(e,t.compose(n,i,l));for(const e in c)"TRANSLATION"!==e&&"ROTATION"!==e&&"SCALE"!==e&&a.geometry.setAttribute(e,c[e]);T.prototype.copy.call(h,a),h.frustumCulled=!1,this.parser.assignFinalMaterial(h),o.push(h)}return n.isGroup?(n.clear(),n.add(...o),n):o[0]})))}}const ae="glTF";class ce{constructor(t){this.name=Vt.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,12),n=new TextDecoder;if(this.header={magic:n.decode(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==ae)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-12,s=new DataView(t,12);let r=0;for(;r<i;){const e=s.getUint32(r,!0);r+=4;const i=s.getUint32(r,!0);if(r+=4,1313821514===i){const i=new Uint8Array(t,12+r,e);this.content=n.decode(i)}else if(5130562===i){const n=12+r;this.body=t.slice(n,n+e)}r+=e}if(null===this.content)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class le{constructor(t,e){if(!e)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Vt.KHR_DRACO_MESH_COMPRESSION,this.json=t,this.dracoLoader=e,this.dracoLoader.preload()}decodePrimitive(t,e){const n=this.json,i=this.dracoLoader,s=t.extensions[this.name].bufferView,r=t.extensions[this.name].attributes,o={},a={},c={};for(const l in r){const t=we[l]||l.toLowerCase();o[t]=r[l]}for(const l in t.attributes){const e=we[l]||l.toLowerCase();if(void 0!==r[l]){const i=n.accessors[t.attributes[l]],s=ge[i.componentType];c[e]=s.name,a[e]=!0===i.normalized}}return e.getDependency("bufferView",s).then((function(t){return new Promise((function(e){i.decodeDracoFile(t,(function(t){for(const e in t.attributes){const n=t.attributes[e],i=a[e];void 0!==i&&(n.normalized=i)}e(t)}),o,c)}))}))}}class he{constructor(){this.name=Vt.KHR_TEXTURE_TRANSFORM}extendTexture(t,e){return e.texCoord,void 0===e.offset&&void 0===e.rotation&&void 0===e.scale||(t=t.clone(),void 0!==e.offset&&t.offset.fromArray(e.offset),void 0!==e.rotation&&(t.rotation=e.rotation),void 0!==e.scale&&t.repeat.fromArray(e.scale),t.needsUpdate=!0),t}}class ue{constructor(){this.name=Vt.KHR_MESH_QUANTIZATION}}class de extends dt{constructor(t,e,n,i){super(t,e,n,i)}copySampleValue_(t){const e=this.resultBuffer,n=this.sampleValues,i=this.valueSize,s=t*i*3+i;for(let r=0;r!==i;r++)e[r]=n[s+r];return e}interpolate_(t,e,n,i){const s=this.resultBuffer,r=this.sampleValues,o=this.valueSize,a=2*o,c=3*o,l=i-e,h=(n-e)/l,u=h*h,d=u*h,p=t*c,m=p-c,f=-2*d+3*u,g=d-u,v=1-f,_=g-u+h;for(let A=0;A!==o;A++){const t=r[m+A+o],e=r[m+A+a]*l,n=r[p+A+o],i=r[p+A]*l;s[A]=v*t+_*e+f*n+g*i}return s}}const pe=new s;class me extends de{interpolate_(t,e,n,i){const s=super.interpolate_(t,e,n,i);return pe.fromArray(s).normalize().toArray(s),s}}const fe={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},ge={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},ve={9728:J,9729:R,9984:$,9985:tt,9986:et,9987:I},_e={33071:nt,33648:it,10497:C},Ae={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},we={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},xe={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Se={CUBICSPLINE:void 0,LINEAR:q,STEP:st};function ye(t,e,n){for(const i in n.extensions)void 0===t[i]&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[i]=n.extensions[i])}function Te(t,e){void 0!==e.extras&&"object"==typeof e.extras&&Object.assign(t.userData,e.extras)}function be(t,e){if(t.updateMorphTargets(),void 0!==e.weights)for(let n=0,i=e.weights.length;n<i;n++)t.morphTargetInfluences[n]=e.weights[n];if(e.extras&&Array.isArray(e.extras.targetNames)){const n=e.extras.targetNames;if(t.morphTargetInfluences.length===n.length){t.morphTargetDictionary={};for(let e=0,i=n.length;e<i;e++)t.morphTargetDictionary[n[e]]=e}}}function Le(t){const e=t.extensions&&t.extensions[Vt.KHR_DRACO_MESH_COMPRESSION];let n;return n=e?"draco:"+e.bufferView+":"+e.indices+":"+Ee(e.attributes):t.indices+":"+Ee(t.attributes)+":"+t.mode,n}function Ee(t){let e="";const n=Object.keys(t).sort();for(let i=0,s=n.length;i<s;i++)e+=n[i]+":"+t[n[i]]+";";return e}function Me(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}const Re=new S;class Ie{constructor(t={},e={}){this.json=t,this.extensions={},this.plugins={},this.options=e,this.cache=new Kt,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,i=!1,s=-1;"undefined"!=typeof navigator&&(n=!0===/^((?!chrome|android).)*safari/i.test(navigator.userAgent),i=navigator.userAgent.indexOf("Firefox")>-1,s=i?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),"undefined"==typeof createImageBitmap||n||i&&s<98?this.textureLoader=new b(this.options.manager):this.textureLoader=new L(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new m(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),"use-credentials"===this.options.crossOrigin&&this.fileLoader.setWithCredentials(!0)}setExtensions(t){this.extensions=t}setPlugins(t){this.plugins=t}parse(t,e){const n=this,i=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll((function(t){return t._markDefs&&t._markDefs()})),Promise.all(this._invokeAll((function(t){return t.beforeRoot&&t.beforeRoot()}))).then((function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])})).then((function(e){const r={scene:e[0][i.scene||0],scenes:e[0],animations:e[1],cameras:e[2],asset:i.asset,parser:n,userData:{}};ye(s,r,i),Te(r,i),Promise.all(n._invokeAll((function(t){return t.afterRoot&&t.afterRoot(r)}))).then((function(){t(r)}))})).catch(e)}_markDefs(){const t=this.json.nodes||[],e=this.json.skins||[],n=this.json.meshes||[];for(let i=0,s=e.length;i<s;i++){const n=e[i].joints;for(let e=0,i=n.length;e<i;e++)t[n[e]].isBone=!0}for(let i=0,s=t.length;i<s;i++){const e=t[i];void 0!==e.mesh&&(this._addNodeRef(this.meshCache,e.mesh),void 0!==e.skin&&(n[e.mesh].isSkinnedMesh=!0)),void 0!==e.camera&&this._addNodeRef(this.cameraCache,e.camera)}}_addNodeRef(t,e){void 0!==e&&(void 0===t.refs[e]&&(t.refs[e]=t.uses[e]=0),t.refs[e]++)}_getNodeRef(t,e,n){if(t.refs[e]<=1)return n;const i=n.clone(),s=(t,e)=>{const n=this.associations.get(t);null!=n&&this.associations.set(e,n);for(const[i,r]of t.children.entries())s(r,e.children[i])};return s(n,i),i.name+="_instance_"+t.uses[e]++,i}_invokeOne(t){const e=Object.values(this.plugins);e.push(this);for(let n=0;n<e.length;n++){const i=t(e[n]);if(i)return i}return null}_invokeAll(t){const e=Object.values(this.plugins);e.unshift(this);const n=[];for(let i=0;i<e.length;i++){const s=t(e[i]);s&&n.push(s)}return n}getDependency(t,e){const n=t+":"+e;let i=this.cache.get(n);if(!i){switch(t){case"scene":i=this.loadScene(e);break;case"node":i=this._invokeOne((function(t){return t.loadNode&&t.loadNode(e)}));break;case"mesh":i=this._invokeOne((function(t){return t.loadMesh&&t.loadMesh(e)}));break;case"accessor":i=this.loadAccessor(e);break;case"bufferView":i=this._invokeOne((function(t){return t.loadBufferView&&t.loadBufferView(e)}));break;case"buffer":i=this.loadBuffer(e);break;case"material":i=this._invokeOne((function(t){return t.loadMaterial&&t.loadMaterial(e)}));break;case"texture":i=this._invokeOne((function(t){return t.loadTexture&&t.loadTexture(e)}));break;case"skin":i=this.loadSkin(e);break;case"animation":i=this._invokeOne((function(t){return t.loadAnimation&&t.loadAnimation(e)}));break;case"camera":i=this.loadCamera(e);break;default:if(i=this._invokeOne((function(n){return n!=this&&n.getDependency&&n.getDependency(t,e)})),!i)throw new Error("Unknown type: "+t)}this.cache.add(n,i)}return i}getDependencies(t){let e=this.cache.get(t);if(!e){const n=this,i=this.json[t+("mesh"===t?"es":"s")]||[];e=Promise.all(i.map((function(e,i){return n.getDependency(t,i)}))),this.cache.add(t,e)}return e}loadBuffer(t){const e=this.json.buffers[t],n=this.fileLoader;if(e.type&&"arraybuffer"!==e.type)throw new Error("THREE.GLTFLoader: "+e.type+" buffer type is not supported.");if(void 0===e.uri&&0===t)return Promise.resolve(this.extensions[Vt.KHR_BINARY_GLTF].body);const i=this.options;return new Promise((function(t,s){n.load(p.resolveURL(e.uri,i.path),t,void 0,(function(){s(new Error('THREE.GLTFLoader: Failed to load buffer "'+e.uri+'".'))}))}))}loadBufferView(t){const e=this.json.bufferViews[t];return this.getDependency("buffer",e.buffer).then((function(t){const n=e.byteLength||0,i=e.byteOffset||0;return t.slice(i,i+n)}))}loadAccessor(t){const e=this,n=this.json,i=this.json.accessors[t];if(void 0===i.bufferView&&void 0===i.sparse){const t=Ae[i.type],e=ge[i.componentType],n=!0===i.normalized,s=new e(i.count*t);return Promise.resolve(new c(s,t,n))}const s=[];return void 0!==i.bufferView?s.push(this.getDependency("bufferView",i.bufferView)):s.push(null),void 0!==i.sparse&&(s.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(s).then((function(t){const s=t[0],r=Ae[i.type],o=ge[i.componentType],a=o.BYTES_PER_ELEMENT,l=a*r,h=i.byteOffset||0,u=void 0!==i.bufferView?n.bufferViews[i.bufferView].byteStride:void 0,d=!0===i.normalized;let p,m;if(u&&u!==l){const t=Math.floor(h/u),n="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+t+":"+i.count;let c=e.cache.get(n);c||(p=new o(s,t*u,i.count*u/a),c=new E(p,u/a),e.cache.add(n,c)),m=new M(c,r,h%u/a,d)}else p=null===s?new o(i.count*r):new o(s,h,i.count*r),m=new c(p,r,d);if(void 0!==i.sparse){const e=Ae.SCALAR,n=ge[i.sparse.indices.componentType],a=i.sparse.indices.byteOffset||0,l=i.sparse.values.byteOffset||0,h=new n(t[1],a,i.sparse.count*e),u=new o(t[2],l,i.sparse.count*r);null!==s&&(m=new c(m.array.slice(),m.itemSize,m.normalized));for(let t=0,i=h.length;t<i;t++){const e=h[t];if(m.setX(e,u[t*r]),r>=2&&m.setY(e,u[t*r+1]),r>=3&&m.setZ(e,u[t*r+2]),r>=4&&m.setW(e,u[t*r+3]),r>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return m}))}loadTexture(t){const e=this.json,n=this.options,i=e.textures[t].source,s=e.images[i];let r=this.textureLoader;if(s.uri){const t=n.manager.getHandler(s.uri);null!==t&&(r=t)}return this.loadTextureImage(t,i,r)}loadTextureImage(t,e,n){const i=this,s=this.json,r=s.textures[t],o=s.images[e],a=(o.uri||o.bufferView)+":"+r.sampler;if(this.textureCache[a])return this.textureCache[a];const c=this.loadImageSource(e,n).then((function(e){e.flipY=!1,e.name=r.name||o.name||"";const n=(s.samplers||{})[r.sampler]||{};return e.magFilter=ve[n.magFilter]||R,e.minFilter=ve[n.minFilter]||I,e.wrapS=_e[n.wrapS]||C,e.wrapT=_e[n.wrapT]||C,i.associations.set(e,{textures:t}),e})).catch((function(){return null}));return this.textureCache[a]=c,c}loadImageSource(t,e){const n=this.json,i=this.options;if(void 0!==this.sourceCache[t])return this.sourceCache[t].then((t=>t.clone()));const s=n.images[t],r=self.URL||self.webkitURL;let o=s.uri||"",a=!1;if(void 0!==s.bufferView)o=this.getDependency("bufferView",s.bufferView).then((function(t){a=!0;const e=new Blob([t],{type:s.mimeType});return o=r.createObjectURL(e),o}));else if(void 0===s.uri)throw new Error("THREE.GLTFLoader: Image "+t+" is missing URI and bufferView");const c=Promise.resolve(o).then((function(t){return new Promise((function(n,s){let r=n;!0===e.isImageBitmapLoader&&(r=function(t){const e=new ot(t);e.needsUpdate=!0,n(e)}),e.load(p.resolveURL(t,i.path),r,void 0,s)}))})).then((function(t){var e;return!0===a&&r.revokeObjectURL(o),t.userData.mimeType=s.mimeType||((e=s.uri).search(/\.jpe?g($|\?)/i)>0||0===e.search(/^data\:image\/jpeg/)?"image/jpeg":e.search(/\.webp($|\?)/i)>0||0===e.search(/^data\:image\/webp/)?"image/webp":"image/png"),t})).catch((function(t){throw t}));return this.sourceCache[t]=c,c}assignTexture(t,e,n,i){const s=this;return this.getDependency("texture",n.index).then((function(r){if(!r)return null;if(void 0===n.texCoord||0==n.texCoord||"aoMap"===e&&n.texCoord,s.extensions[Vt.KHR_TEXTURE_TRANSFORM]){const t=void 0!==n.extensions?n.extensions[Vt.KHR_TEXTURE_TRANSFORM]:void 0;if(t){const e=s.associations.get(r);r=s.extensions[Vt.KHR_TEXTURE_TRANSFORM].extendTexture(r,t),s.associations.set(r,e)}}return void 0!==i&&(r.encoding=i),t[e]=r,r}))}assignFinalMaterial(t){const e=t.geometry;let n=t.material;const i=void 0===e.attributes.tangent,s=void 0!==e.attributes.color,r=void 0===e.attributes.normal;if(t.isPoints){const t="PointsMaterial:"+n.uuid;let e=this.cache.get(t);e||(e=new P,D.prototype.copy.call(e,n),e.color.copy(n.color),e.map=n.map,e.sizeAttenuation=!1,this.cache.add(t,e)),n=e}else if(t.isLine){const t="LineBasicMaterial:"+n.uuid;let e=this.cache.get(t);e||(e=new O,D.prototype.copy.call(e,n),e.color.copy(n.color),this.cache.add(t,e)),n=e}if(i||s||r){let t="ClonedMaterial:"+n.uuid+":";i&&(t+="derivative-tangents:"),s&&(t+="vertex-colors:"),r&&(t+="flat-shading:");let e=this.cache.get(t);e||(e=n.clone(),s&&(e.vertexColors=!0),r&&(e.flatShading=!0),i&&(e.normalScale&&(e.normalScale.y*=-1),e.clearcoatNormalScale&&(e.clearcoatNormalScale.y*=-1)),this.cache.add(t,e),this.associations.set(e,this.associations.get(n))),n=e}n.aoMap&&void 0===e.attributes.uv2&&void 0!==e.attributes.uv&&e.setAttribute("uv2",e.attributes.uv),t.material=n}getMaterialType(){return N}loadMaterial(t){const e=this,n=this.json,i=this.extensions,s=n.materials[t];let r;const a={},c=[];if((s.extensions||{})[Vt.KHR_MATERIALS_UNLIT]){const t=i[Vt.KHR_MATERIALS_UNLIT];r=t.getMaterialType(),c.push(t.extendParams(a,s,e))}else{const n=s.pbrMetallicRoughness||{};if(a.color=new f(1,1,1),a.opacity=1,Array.isArray(n.baseColorFactor)){const t=n.baseColorFactor;a.color.fromArray(t),a.opacity=t[3]}void 0!==n.baseColorTexture&&c.push(e.assignTexture(a,"map",n.baseColorTexture,w)),a.metalness=void 0!==n.metallicFactor?n.metallicFactor:1,a.roughness=void 0!==n.roughnessFactor?n.roughnessFactor:1,void 0!==n.metallicRoughnessTexture&&(c.push(e.assignTexture(a,"metalnessMap",n.metallicRoughnessTexture)),c.push(e.assignTexture(a,"roughnessMap",n.metallicRoughnessTexture))),r=this._invokeOne((function(e){return e.getMaterialType&&e.getMaterialType(t)})),c.push(Promise.all(this._invokeAll((function(e){return e.extendMaterialParams&&e.extendMaterialParams(t,a)}))))}!0===s.doubleSided&&(a.side=k);const l=s.alphaMode||"OPAQUE";if("BLEND"===l?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,"MASK"===l&&(a.alphaTest=void 0!==s.alphaCutoff?s.alphaCutoff:.5)),void 0!==s.normalTexture&&r!==A&&(c.push(e.assignTexture(a,"normalMap",s.normalTexture)),a.normalScale=new o(1,1),void 0!==s.normalTexture.scale)){const t=s.normalTexture.scale;a.normalScale.set(t,t)}return void 0!==s.occlusionTexture&&r!==A&&(c.push(e.assignTexture(a,"aoMap",s.occlusionTexture)),void 0!==s.occlusionTexture.strength&&(a.aoMapIntensity=s.occlusionTexture.strength)),void 0!==s.emissiveFactor&&r!==A&&(a.emissive=(new f).fromArray(s.emissiveFactor)),void 0!==s.emissiveTexture&&r!==A&&c.push(e.assignTexture(a,"emissiveMap",s.emissiveTexture,w)),Promise.all(c).then((function(){const n=new r(a);return s.name&&(n.name=s.name),Te(n,s),e.associations.set(n,{materials:t}),s.extensions&&ye(i,n,s),n}))}createUniqueName(t){const e=F.sanitizeNodeName(t||"");let n=e;for(let i=1;this.nodeNamesUsed[n];++i)n=e+"_"+i;return this.nodeNamesUsed[n]=!0,n}loadGeometries(t){const e=this,n=this.extensions,i=this.primitiveCache;function s(t){return n[Vt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t,e).then((function(n){return Ce(n,t,e)}))}const r=[];for(let o=0,c=t.length;o<c;o++){const n=t[o],c=Le(n),l=i[c];if(l)r.push(l.promise);else{let t;t=n.extensions&&n.extensions[Vt.KHR_DRACO_MESH_COMPRESSION]?s(n):Ce(new a,n,e),i[c]={primitive:n,promise:t},r.push(t)}}return Promise.all(r)}loadMesh(t){const e=this,n=this.json,i=this.extensions,s=n.meshes[t],r=s.primitives,o=[];for(let c=0,l=r.length;c<l;c++){const t=void 0===r[c].material?(void 0===(a=this.cache).DefaultMaterial&&(a.DefaultMaterial=new N({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:rt})),a.DefaultMaterial):this.getDependency("material",r[c].material);o.push(t)}var a;return o.push(e.loadGeometries(r)),Promise.all(o).then((function(n){const o=n.slice(0,n.length-1),a=n[n.length-1],c=[];for(let d=0,p=a.length;d<p;d++){const n=a[d],l=r[d];let p;const m=o[d];if(l.mode===fe.TRIANGLES||l.mode===fe.TRIANGLE_STRIP||l.mode===fe.TRIANGLE_FAN||void 0===l.mode)p=!0===s.isSkinnedMesh?new U(n,m):new H(n,m),!0===p.isSkinnedMesh&&p.normalizeSkinWeights(),l.mode===fe.TRIANGLE_STRIP?p.geometry=zt(p.geometry,u):l.mode===fe.TRIANGLE_FAN&&(p.geometry=zt(p.geometry,h));else if(l.mode===fe.LINES)p=new B(n,m);else if(l.mode===fe.LINE_STRIP)p=new j(n,m);else if(l.mode===fe.LINE_LOOP)p=new z(n,m);else{if(l.mode!==fe.POINTS)throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+l.mode);p=new G(n,m)}Object.keys(p.geometry.morphAttributes).length>0&&be(p,s),p.name=e.createUniqueName(s.name||"mesh_"+t),Te(p,s),l.extensions&&ye(i,p,l),e.assignFinalMaterial(p),c.push(p)}for(let i=0,s=c.length;i<s;i++)e.associations.set(c[i],{meshes:t,primitives:i});if(1===c.length)return c[0];const l=new K;e.associations.set(l,{meshes:t});for(let t=0,e=c.length;t<e;t++)l.add(c[t]);return l}))}loadCamera(t){let e;const n=this.json.cameras[t],i=n[n.type];if(i)return"perspective"===n.type?e=new V(X.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):"orthographic"===n.type&&(e=new W(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),n.name&&(e.name=this.createUniqueName(n.name)),Te(e,n),Promise.resolve(e)}loadSkin(t){const e=this.json.skins[t],n=[];for(let i=0,s=e.joints.length;i<s;i++)n.push(this._loadNodeShallow(e.joints[i]));return void 0!==e.inverseBindMatrices?n.push(this.getDependency("accessor",e.inverseBindMatrices)):n.push(null),Promise.all(n).then((function(t){const e=t.pop(),n=t,i=[],s=[];for(let r=0,o=n.length;r<o;r++){const t=n[r];if(t){i.push(t);const n=new S;null!==e&&n.fromArray(e.array,16*r),s.push(n)}}return new Y(i,s)}))}loadAnimation(t){const e=this.json.animations[t],n=[],i=[],s=[],r=[],o=[];for(let a=0,c=e.channels.length;a<c;a++){const t=e.channels[a],c=e.samplers[t.sampler],l=t.target,h=l.node,u=void 0!==e.parameters?e.parameters[c.input]:c.input,d=void 0!==e.parameters?e.parameters[c.output]:c.output;n.push(this.getDependency("node",h)),i.push(this.getDependency("accessor",u)),s.push(this.getDependency("accessor",d)),r.push(c),o.push(l)}return Promise.all([Promise.all(n),Promise.all(i),Promise.all(s),Promise.all(r),Promise.all(o)]).then((function(n){const i=n[0],s=n[1],r=n[2],o=n[3],a=n[4],c=[];for(let t=0,e=i.length;t<e;t++){const e=i[t],n=s[t],l=r[t],h=o[t],u=a[t];if(void 0===e)continue;let d;switch(e.updateMatrix(),xe[u.path]){case xe.weights:d=lt;break;case xe.rotation:d=ct;break;default:d=at}const p=e.name?e.name:e.uuid,m=void 0!==h.interpolation?Se[h.interpolation]:q,f=[];xe[u.path]===xe.weights?e.traverse((function(t){t.morphTargetInfluences&&f.push(t.name?t.name:t.uuid)})):f.push(p);let g=l.array;if(l.normalized){const t=Me(g.constructor),e=new Float32Array(g.length);for(let n=0,i=g.length;n<i;n++)e[n]=g[n]*t;g=e}for(let t=0,i=f.length;t<i;t++){const e=new d(f[t]+"."+xe[u.path],n.array,g,m);"CUBICSPLINE"===h.interpolation&&(e.createInterpolant=function(t){return new(this instanceof ct?me:de)(this.times,this.values,this.getValueSize()/3,t)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),c.push(e)}}const l=e.name?e.name:"animation_"+t;return new Z(l,void 0,c)}))}createNodeMesh(t){const e=this.json,n=this,i=e.nodes[t];return void 0===i.mesh?null:n.getDependency("mesh",i.mesh).then((function(t){const e=n._getNodeRef(n.meshCache,i.mesh,t);return void 0!==i.weights&&e.traverse((function(t){if(t.isMesh)for(let e=0,n=i.weights.length;e<n;e++)t.morphTargetInfluences[e]=i.weights[e]})),e}))}loadNode(t){const e=this,n=this.json.nodes[t],i=e._loadNodeShallow(t),s=[],r=n.children||[];for(let a=0,c=r.length;a<c;a++)s.push(e.getDependency("node",r[a]));const o=void 0===n.skin?Promise.resolve(null):e.getDependency("skin",n.skin);return Promise.all([i,Promise.all(s),o]).then((function(t){const e=t[0],n=t[1],i=t[2];null!==i&&e.traverse((function(t){t.isSkinnedMesh&&t.bind(i,Re)}));for(let s=0,r=n.length;s<r;s++)e.add(n[s]);return e}))}_loadNodeShallow(t){const e=this.json,n=this.extensions,i=this;if(void 0!==this.nodeCache[t])return this.nodeCache[t];const s=e.nodes[t],r=s.name?i.createUniqueName(s.name):"",o=[],a=i._invokeOne((function(e){return e.createNodeMesh&&e.createNodeMesh(t)}));return a&&o.push(a),void 0!==s.camera&&o.push(i.getDependency("camera",s.camera).then((function(t){return i._getNodeRef(i.cameraCache,s.camera,t)}))),i._invokeAll((function(e){return e.createNodeAttachment&&e.createNodeAttachment(t)})).forEach((function(t){o.push(t)})),this.nodeCache[t]=Promise.all(o).then((function(e){let o;if(o=!0===s.isBone?new Q:e.length>1?new K:1===e.length?e[0]:new T,o!==e[0])for(let t=0,n=e.length;t<n;t++)o.add(e[t]);if(s.name&&(o.userData.name=s.name,o.name=r),Te(o,s),s.extensions&&ye(n,o,s),void 0!==s.matrix){const t=new S;t.fromArray(s.matrix),o.applyMatrix4(t)}else void 0!==s.translation&&o.position.fromArray(s.translation),void 0!==s.rotation&&o.quaternion.fromArray(s.rotation),void 0!==s.scale&&o.scale.fromArray(s.scale);return i.associations.has(o)||i.associations.set(o,{}),i.associations.get(o).nodes=t,o})),this.nodeCache[t]}loadScene(t){const e=this.extensions,n=this.json.scenes[t],i=this,s=new K;n.name&&(s.name=i.createUniqueName(n.name)),Te(s,n),n.extensions&&ye(e,s,n);const r=n.nodes||[],o=[];for(let a=0,c=r.length;a<c;a++)o.push(i.getDependency("node",r[a]));return Promise.all(o).then((function(t){for(let e=0,n=t.length;e<n;e++)s.add(t[e]);return i.associations=(t=>{const e=new Map;for(const[n,s]of i.associations)(n instanceof D||n instanceof ot)&&e.set(n,s);return t.traverse((t=>{const n=i.associations.get(t);null!=n&&e.set(t,n)})),e})(s),s}))}}function Ce(t,n,i){const s=n.attributes,r=[];function o(e,n){return i.getDependency("accessor",e).then((function(e){t.setAttribute(n,e)}))}for(const e in s){const n=we[e]||e.toLowerCase();n in t.attributes||r.push(o(s[e],n))}if(void 0!==n.indices&&!t.index){const e=i.getDependency("accessor",n.indices).then((function(e){t.setIndex(e)}));r.push(e)}return Te(t,n),function(t,n,i){const s=n.attributes,r=new ht;if(void 0===s.POSITION)return;{const t=i.json.accessors[s.POSITION],n=t.min,o=t.max;if(void 0===n||void 0===o)return;if(r.set(new e(n[0],n[1],n[2]),new e(o[0],o[1],o[2])),t.normalized){const e=Me(ge[t.componentType]);r.min.multiplyScalar(e),r.max.multiplyScalar(e)}}const o=n.targets;if(void 0!==o){const t=new e,n=new e;for(let e=0,s=o.length;e<s;e++){const s=o[e];if(void 0!==s.POSITION){const e=i.json.accessors[s.POSITION],r=e.min,o=e.max;if(void 0!==r&&void 0!==o){if(n.setX(Math.max(Math.abs(r[0]),Math.abs(o[0]))),n.setY(Math.max(Math.abs(r[1]),Math.abs(o[1]))),n.setZ(Math.max(Math.abs(r[2]),Math.abs(o[2]))),e.normalized){const t=Me(ge[e.componentType]);n.multiplyScalar(t)}t.max(n)}}}r.expandByVector(t)}t.boundingBox=r;const a=new ut;r.getCenter(a.center),a.radius=r.min.distanceTo(r.max)/2,t.boundingSphere=a}(t,n,i),Promise.all(r).then((function(){return void 0!==n.targets?function(t,e,n){let i=!1,s=!1,r=!1;for(let l=0,h=e.length;l<h;l++){const t=e[l];if(void 0!==t.POSITION&&(i=!0),void 0!==t.NORMAL&&(s=!0),void 0!==t.COLOR_0&&(r=!0),i&&s&&r)break}if(!i&&!s&&!r)return Promise.resolve(t);const o=[],a=[],c=[];for(let l=0,h=e.length;l<h;l++){const h=e[l];if(i){const e=void 0!==h.POSITION?n.getDependency("accessor",h.POSITION):t.attributes.position;o.push(e)}if(s){const e=void 0!==h.NORMAL?n.getDependency("accessor",h.NORMAL):t.attributes.normal;a.push(e)}if(r){const e=void 0!==h.COLOR_0?n.getDependency("accessor",h.COLOR_0):t.attributes.color;c.push(e)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(c)]).then((function(e){const n=e[0],o=e[1],a=e[2];return i&&(t.morphAttributes.position=n),s&&(t.morphAttributes.normal=o),r&&(t.morphAttributes.color=a),t.morphTargetsRelative=!0,t}))}(t,n.targets,i):t}))}class Pe extends H{constructor(){super(Pe.Geometry,new A({opacity:0,transparent:!0})),this.isLensflare=!0,this.type="Lensflare",this.frustumCulled=!1,this.renderOrder=1/0;const t=new e,n=new e,i=new pt(16,16,mt),s=new pt(16,16,mt),r=Pe.Geometry,a=new ft({uniforms:{scale:{value:null},screenPosition:{value:null}},vertexShader:"\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}",fragmentShader:"\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 1.0 );\n\n\t\t\t\t}",depthTest:!0,depthWrite:!1,transparent:!1}),c=new ft({uniforms:{map:{value:i},scale:{value:null},screenPosition:{value:null}},vertexShader:"\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform vec3 screenPosition;\n\t\t\t\tuniform vec2 scale;\n\n\t\t\t\tattribute vec3 position;\n\t\t\t\tattribute vec2 uv;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvUV = uv;\n\n\t\t\t\t\tgl_Position = vec4( position.xy * scale + screenPosition.xy, screenPosition.z, 1.0 );\n\n\t\t\t\t}",fragmentShader:"\n\n\t\t\t\tprecision highp float;\n\n\t\t\t\tuniform sampler2D map;\n\n\t\t\t\tvarying vec2 vUV;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tgl_FragColor = texture2D( map, vUV );\n\n\t\t\t\t}",depthTest:!1,depthWrite:!1,transparent:!1}),l=new H(r,a),h=[],u=De.Shader,d=new ft({uniforms:{map:{value:null},occlusionMap:{value:s},color:{value:new f(16777215)},scale:{value:new o},screenPosition:{value:new e}},vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,blending:gt,transparent:!0,depthWrite:!1}),p=new H(r,d);this.addElement=function(t){h.push(t)};const m=new o,g=new o,v=new vt,_=new _t;this.onBeforeRender=function(e,o,u){e.getCurrentViewport(_);const f=_.w/_.z,A=_.z/2,w=_.w/2;let x=16/_.w;if(m.set(x*f,x),v.min.set(_.x,_.y),v.max.set(_.x+(_.z-16),_.y+(_.w-16)),n.setFromMatrixPosition(this.matrixWorld),n.applyMatrix4(u.matrixWorldInverse),!(n.z>0)&&(t.copy(n).applyMatrix4(u.projectionMatrix),g.x=_.x+t.x*A+A-8,g.y=_.y+t.y*w+w-8,v.containsPoint(g))){e.copyFramebufferToTexture(g,i);let n=a.uniforms;n.scale.value=m,n.screenPosition.value=t,e.renderBufferDirect(u,null,r,a,l,null),e.copyFramebufferToTexture(g,s),n=c.uniforms,n.scale.value=m,n.screenPosition.value=t,e.renderBufferDirect(u,null,r,c,l,null);const o=2*-t.x,f=2*-t.y;for(let i=0,s=h.length;i<s;i++){const n=h[i],s=d.uniforms;s.color.value.copy(n.color),s.map.value=n.texture,s.screenPosition.value.x=t.x+o*n.distance,s.screenPosition.value.y=t.y+f*n.distance,x=n.size/_.w;const a=_.w/_.z;s.scale.value.set(x*a,x),d.uniformsNeedUpdate=!0,e.renderBufferDirect(u,null,r,d,p,null)}}},this.dispose=function(){a.dispose(),c.dispose(),d.dispose(),i.dispose(),s.dispose();for(let t=0,e=h.length;t<e;t++)h[t].texture.dispose()}}}class De{constructor(t,e=1,n=0,i=new f(16777215)){this.texture=t,this.size=e,this.distance=n,this.color=i}}De.Shader={uniforms:{map:{value:null},occlusionMap:{value:null},color:{value:null},scale:{value:null},screenPosition:{value:null}},vertexShader:"\n\n\t\tprecision highp float;\n\n\t\tuniform vec3 screenPosition;\n\t\tuniform vec2 scale;\n\n\t\tuniform sampler2D occlusionMap;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvUV = uv;\n\n\t\t\tvec2 pos = position.xy;\n\n\t\t\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\n\t\t\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\n\n\t\t\tvVisibility =        visibility.r / 9.0;\n\t\t\tvVisibility *= 1.0 - visibility.g / 9.0;\n\t\t\tvVisibility *=       visibility.b / 9.0;\n\n\t\t\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tprecision highp float;\n\n\t\tuniform sampler2D map;\n\t\tuniform vec3 color;\n\n\t\tvarying vec2 vUV;\n\t\tvarying float vVisibility;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texture = texture2D( map, vUV );\n\t\t\ttexture.a *= vVisibility;\n\t\t\tgl_FragColor = texture;\n\t\t\tgl_FragColor.rgb *= color;\n\n\t\t}"},Pe.Geometry=function(){const t=new a,e=new Float32Array([-1,-1,0,0,0,1,-1,0,1,0,1,1,0,1,1,-1,1,0,0,1]),n=new E(e,5);return t.setIndex([0,1,2,0,2,3]),t.setAttribute("position",new M(n,3,0,!1)),t.setAttribute("uv",new M(n,2,3,!1)),t}();class Oe extends H{constructor(){const t=Oe.SkyShader,e=new At({name:"SkyShader",fragmentShader:t.fragmentShader,vertexShader:t.vertexShader,uniforms:wt.clone(t.uniforms),side:xt,depthWrite:!1});super(new St(1,1,1),e),this.isSky=!0}}Oe.SkyShader={uniforms:{turbidity:{value:2},rayleigh:{value:1},mieCoefficient:{value:.005},mieDirectionalG:{value:.8},sunPosition:{value:new e},up:{value:new e(0,1,0)}},vertexShader:"\n\t\tuniform vec3 sunPosition;\n\t\tuniform float rayleigh;\n\t\tuniform float turbidity;\n\t\tuniform float mieCoefficient;\n\t\tuniform vec3 up;\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\t// constants for atmospheric scattering\n\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\t// wavelength of used primaries, according to preetham\n\t\tconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\tconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\tconst float v = 4.0;\n\t\tconst vec3 K = vec3( 0.686, 0.678, 0.666 );\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\tconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\tconst float cutoffAngle = 1.6110731556870734;\n\t\tconst float steepness = 1.5;\n\t\tconst float EE = 1000.0;\n\n\t\tfloat sunIntensity( float zenithAngleCos ) {\n\t\t\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n\t\t\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n\t\t}\n\n\t\tvec3 totalMie( float T ) {\n\t\t\tfloat c = ( 0.2 * T ) * 10E-18;\n\t\t\treturn 0.434 * c * MieConst;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\t\t\tvWorldPosition = worldPosition.xyz;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n\t\t\tvSunDirection = normalize( sunPosition );\n\n\t\t\tvSunE = sunIntensity( dot( vSunDirection, up ) );\n\n\t\t\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n\t\t\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n\t\t\t// extinction (absorbtion + out scattering)\n\t\t\t// rayleigh coefficients\n\t\t\tvBetaR = totalRayleigh * rayleighCoefficient;\n\n\t\t\t// mie coefficients\n\t\t\tvBetaM = totalMie( turbidity ) * mieCoefficient;\n\n\t\t}",fragmentShader:"\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\tuniform float mieDirectionalG;\n\t\tuniform vec3 up;\n\n\t\tconst vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n\t\t// constants for atmospheric scattering\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\tconst float n = 1.0003; // refractive index of air\n\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\tconst float rayleighZenithLength = 8.4E3;\n\t\tconst float mieZenithLength = 1.25E3;\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\tconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n\t\t// 1.0 / ( 4.0 * pi )\n\t\tconst float ONE_OVER_FOURPI = 0.07957747154594767;\n\n\t\tfloat rayleighPhase( float cosTheta ) {\n\t\t\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n\t\t}\n\n\t\tfloat hgPhase( float cosTheta, float g ) {\n\t\t\tfloat g2 = pow( g, 2.0 );\n\t\t\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n\t\t\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec3 direction = normalize( vWorldPosition - cameraPos );\n\n\t\t\t// optical length\n\t\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n\t\t\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n\t\t\tfloat sR = rayleighZenithLength * inverse;\n\t\t\tfloat sM = mieZenithLength * inverse;\n\n\t\t\t// combined extinction factor\n\t\t\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n\t\t\t// in scattering\n\t\t\tfloat cosTheta = dot( direction, vSunDirection );\n\n\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\t\t\tvec3 betaRTheta = vBetaR * rPhase;\n\n\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\t\t\tvec3 betaMTheta = vBetaM * mPhase;\n\n\t\t\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n\t\t\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n\t\t\t// nightsky\n\t\t\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n\t\t\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n\t\t\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n\t\t\tvec3 L0 = vec3( 0.1 ) * Fex;\n\n\t\t\t// composition + solar disc\n\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\t\t\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n\t\t\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n\t\t\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n\t\t\tgl_FragColor = vec4( retColor, 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}"};class Ne extends H{constructor(t,n={}){super(t),this.isWater=!0;const i=this,s=void 0!==n.textureWidth?n.textureWidth:512,r=void 0!==n.textureHeight?n.textureHeight:512,o=void 0!==n.clipBias?n.clipBias:0,a=void 0!==n.alpha?n.alpha:1,c=void 0!==n.time?n.time:0,l=void 0!==n.waterNormals?n.waterNormals:null,h=void 0!==n.sunDirection?n.sunDirection:new e(.70707,.70707,0),u=new f(void 0!==n.sunColor?n.sunColor:16777215),d=new f(void 0!==n.waterColor?n.waterColor:8355711),p=void 0!==n.eye?n.eye:new e(0,0,0),m=void 0!==n.distortionScale?n.distortionScale:20,g=void 0!==n.side?n.side:rt,v=void 0!==n.fog&&n.fog,_=new yt,A=new e,w=new e,x=new e,y=new S,T=new e(0,0,-1),b=new _t,L=new e,E=new e,M=new _t,R=new S,I=new V,C=new Tt(s,r),P={uniforms:wt.merge([bt.fog,bt.lights,{normalSampler:{value:null},mirrorSampler:{value:null},alpha:{value:1},time:{value:0},size:{value:1},distortionScale:{value:20},textureMatrix:{value:new S},sunColor:{value:new f(8355711)},sunDirection:{value:new e(.70707,.70707,0)},eye:{value:new e},waterColor:{value:new f(5592405)}}]),vertexShader:"\n\t\t\t\tuniform mat4 textureMatrix;\n\t\t\t\tuniform float time;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <fog_pars_vertex>\n\t\t\t\t#include <shadowmap_pars_vertex>\n\t\t\t\t#include <logdepthbuf_pars_vertex>\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tmirrorCoord = modelMatrix * vec4( position, 1.0 );\n\t\t\t\t\tworldPosition = mirrorCoord.xyzw;\n\t\t\t\t\tmirrorCoord = textureMatrix * mirrorCoord;\n\t\t\t\t\tvec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t\t\t#include <beginnormal_vertex>\n\t\t\t\t#include <defaultnormal_vertex>\n\t\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\t#include <fog_vertex>\n\t\t\t\t#include <shadowmap_vertex>\n\t\t\t}",fragmentShader:"\n\t\t\t\tuniform sampler2D mirrorSampler;\n\t\t\t\tuniform float alpha;\n\t\t\t\tuniform float time;\n\t\t\t\tuniform float size;\n\t\t\t\tuniform float distortionScale;\n\t\t\t\tuniform sampler2D normalSampler;\n\t\t\t\tuniform vec3 sunColor;\n\t\t\t\tuniform vec3 sunDirection;\n\t\t\t\tuniform vec3 eye;\n\t\t\t\tuniform vec3 waterColor;\n\n\t\t\t\tvarying vec4 mirrorCoord;\n\t\t\t\tvarying vec4 worldPosition;\n\n\t\t\t\tvec4 getNoise( vec2 uv ) {\n\t\t\t\t\tvec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);\n\t\t\t\t\tvec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );\n\t\t\t\t\tvec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );\n\t\t\t\t\tvec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );\n\t\t\t\t\tvec4 noise = texture2D( normalSampler, uv0 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv1 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv2 ) +\n\t\t\t\t\t\ttexture2D( normalSampler, uv3 );\n\t\t\t\t\treturn noise * 0.5 - 1.0;\n\t\t\t\t}\n\n\t\t\t\tvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n\t\t\t\t\tvec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n\t\t\t\t\tfloat direction = max( 0.0, dot( eyeDirection, reflection ) );\n\t\t\t\t\tspecularColor += pow( direction, shiny ) * sunColor * spec;\n\t\t\t\t\tdiffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n\t\t\t\t}\n\n\t\t\t\t#include <common>\n\t\t\t\t#include <packing>\n\t\t\t\t#include <bsdfs>\n\t\t\t\t#include <fog_pars_fragment>\n\t\t\t\t#include <logdepthbuf_pars_fragment>\n\t\t\t\t#include <lights_pars_begin>\n\t\t\t\t#include <shadowmap_pars_fragment>\n\t\t\t\t#include <shadowmask_pars_fragment>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <logdepthbuf_fragment>\n\t\t\t\t\tvec4 noise = getNoise( worldPosition.xz * size );\n\t\t\t\t\tvec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );\n\n\t\t\t\t\tvec3 diffuseLight = vec3(0.0);\n\t\t\t\t\tvec3 specularLight = vec3(0.0);\n\n\t\t\t\t\tvec3 worldToEye = eye-worldPosition.xyz;\n\t\t\t\t\tvec3 eyeDirection = normalize( worldToEye );\n\t\t\t\t\tsunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n\t\t\t\t\tfloat distance = length(worldToEye);\n\n\t\t\t\t\tvec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n\t\t\t\t\tvec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n\t\t\t\t\tfloat theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n\t\t\t\t\tfloat rf0 = 0.3;\n\t\t\t\t\tfloat reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n\t\t\t\t\tvec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n\t\t\t\t\tvec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);\n\t\t\t\t\tvec3 outgoingLight = albedo;\n\t\t\t\t\tgl_FragColor = vec4( outgoingLight, alpha );\n\n\t\t\t\t\t#include <tonemapping_fragment>\n\t\t\t\t\t#include <fog_fragment>\n\t\t\t\t}"},D=new At({fragmentShader:P.fragmentShader,vertexShader:P.vertexShader,uniforms:wt.clone(P.uniforms),lights:!0,side:g,fog:v});D.uniforms.mirrorSampler.value=C.texture,D.uniforms.textureMatrix.value=R,D.uniforms.alpha.value=a,D.uniforms.time.value=c,D.uniforms.normalSampler.value=l,D.uniforms.sunColor.value=u,D.uniforms.waterColor.value=d,D.uniforms.sunDirection.value=h,D.uniforms.distortionScale.value=m,D.uniforms.eye.value=p,i.material=D,i.onBeforeRender=function(t,e,n){if(w.setFromMatrixPosition(i.matrixWorld),x.setFromMatrixPosition(n.matrixWorld),y.extractRotation(i.matrixWorld),A.set(0,0,1),A.applyMatrix4(y),L.subVectors(w,x),L.dot(A)>0)return;L.reflect(A).negate(),L.add(w),y.extractRotation(n.matrixWorld),T.set(0,0,-1),T.applyMatrix4(y),T.add(x),E.subVectors(w,T),E.reflect(A).negate(),E.add(w),I.position.copy(L),I.up.set(0,1,0),I.up.applyMatrix4(y),I.up.reflect(A),I.lookAt(E),I.far=n.far,I.updateMatrixWorld(),I.projectionMatrix.copy(n.projectionMatrix),R.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),R.multiply(I.projectionMatrix),R.multiply(I.matrixWorldInverse),_.setFromNormalAndCoplanarPoint(A,w),_.applyMatrix4(I.matrixWorldInverse),b.set(_.normal.x,_.normal.y,_.normal.z,_.constant);const s=I.projectionMatrix;M.x=(Math.sign(b.x)+s.elements[8])/s.elements[0],M.y=(Math.sign(b.y)+s.elements[9])/s.elements[5],M.z=-1,M.w=(1+s.elements[10])/s.elements[14],b.multiplyScalar(2/b.dot(M)),s.elements[2]=b.x,s.elements[6]=b.y,s.elements[10]=b.z+1-o,s.elements[14]=b.w,p.setFromMatrixPosition(n.matrixWorld);const r=t.getRenderTarget(),a=t.xr.enabled,c=t.shadowMap.autoUpdate;i.visible=!1,t.xr.enabled=!1,t.shadowMap.autoUpdate=!1,t.setRenderTarget(C),t.state.buffers.depth.setMask(!0),!1===t.autoClear&&t.clear(),t.render(e,I),i.visible=!0,t.xr.enabled=a,t.shadowMap.autoUpdate=c,t.setRenderTarget(r);const l=n.viewport;void 0!==l&&t.state.viewport(l)}}}const ke=new S;class Fe{constructor(t){t=t||{},this.vertices={near:[new e,new e,new e,new e],far:[new e,new e,new e,new e]},void 0!==t.projectionMatrix&&this.setFromProjectionMatrix(t.projectionMatrix,t.maxFar||1e4)}setFromProjectionMatrix(t,e){const n=0===t.elements[11];return ke.copy(t).invert(),this.vertices.near[0].set(1,1,-1),this.vertices.near[1].set(1,-1,-1),this.vertices.near[2].set(-1,-1,-1),this.vertices.near[3].set(-1,1,-1),this.vertices.near.forEach((function(t){t.applyMatrix4(ke)})),this.vertices.far[0].set(1,1,1),this.vertices.far[1].set(1,-1,1),this.vertices.far[2].set(-1,-1,1),this.vertices.far[3].set(-1,1,1),this.vertices.far.forEach((function(t){t.applyMatrix4(ke);const i=Math.abs(t.z);n?t.z*=Math.min(e/i,1):t.multiplyScalar(Math.min(e/i,1))})),this.vertices}split(t,e){for(;t.length>e.length;)e.push(new Fe);e.length=t.length;for(let n=0;n<t.length;n++){const i=e[n];if(0===n)for(let t=0;t<4;t++)i.vertices.near[t].copy(this.vertices.near[t]);else for(let e=0;e<4;e++)i.vertices.near[e].lerpVectors(this.vertices.near[e],this.vertices.far[e],t[n-1]);if(n===t.length-1)for(let t=0;t<4;t++)i.vertices.far[t].copy(this.vertices.far[t]);else for(let e=0;e<4;e++)i.vertices.far[e].lerpVectors(this.vertices.near[e],this.vertices.far[e],t[n])}}toSpace(t,e){for(let n=0;n<4;n++)e.vertices.near[n].copy(this.vertices.near[n]).applyMatrix4(t),e.vertices.far[n].copy(this.vertices.far[n]).applyMatrix4(t)}}const Ue={lights_fragment_begin:"\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef CLEARCOAT\n\n\tgeometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight = pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight = spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\tfloat linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\n\tvec2 cascade;\n\tfloat cascadeCenter;\n\tfloat closestEdge;\n\tfloat margin;\n\tfloat csmx;\n\tfloat csmy;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t  \t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\t\t// NOTE: Depth gets larger away from the camera.\n\t\t\t// cascade.x is closer, cascade.y is further\n\t\t\tcascade = CSM_cascades[ i ];\n\t\t\tcascadeCenter = ( cascade.x + cascade.y ) / 2.0;\n\t\t\tclosestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\n\t\t\tmargin = 0.25 * pow( closestEdge, 2.0 );\n\t\t\tcsmx = cascade.x - margin / 2.0;\n\t\t\tcsmy = cascade.y + margin / 2.0;\n\t\t\tif( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\n\n\t\t\t\tfloat dist = min( linearDepth - csmx, csmy - linearDepth );\n\t\t\t\tfloat ratio = clamp( dist / margin, 0.0, 1.0 );\n\n\t\t\t\tvec3 prevColor = directLight.color;\n\t\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\t\tbool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\n\t\t\t\tdirectLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\n\n\t\t\t\tReflectedLight prevLight = reflectedLight;\n\t\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t\t\tbool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\n\t\t\t\tfloat blendRatio = shouldBlend ? ratio : 1.0;\n\n\t\t\t\treflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\n\t\t\t\treflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\n\t\t\t\treflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\n\t\t\t\treflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\n\n\t\t\t}\n\t  \t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\t#else\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\t\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\n\t\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n\t\t\tif(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t\t#endif\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n\t#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)\n\t\t// compute the lights not casting shadows (if any)\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\n\t\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight = directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance = vec3( 0.0 );\n\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",lights_pars_begin:"\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\nuniform vec2 CSM_cascades[CSM_CASCADES];\nuniform float cameraNear;\nuniform float shadowFar;\n#endif\n\t"+Lt.lights_pars_begin},He=new S,Be=new Fe,je=new e,ze=new ht,Ge=[],Ke=[],Ve=new S,Xe=new S,We=new e(0,1,0);class Ye{constructor(t){t=t||{},this.camera=t.camera,this.parent=t.parent,this.cascades=t.cascades||3,this.maxFar=t.maxFar||1e5,this.mode=t.mode||"practical",this.shadowMapSize=t.shadowMapSize||2048,this.shadowBias=t.shadowBias||1e-6,this.lightDirection=t.lightDirection||new e(1,-1,1).normalize(),this.lightIntensity=t.lightIntensity||1,this.lightNear=t.lightNear||1,this.lightFar=t.lightFar||2e3,this.lightMargin=t.lightMargin||200,this.customSplitsCallback=t.customSplitsCallback,this.fade=!1,this.mainFrustum=new Fe,this.frustums=[],this.breaks=[],this.lights=[],this.shaders=new Map,this.createLights(),this.updateFrustums(),this.injectInclude()}createLights(){for(let t=0;t<this.cascades;t++){const t=new _(16777215,this.lightIntensity);t.castShadow=!0,t.shadow.mapSize.width=this.shadowMapSize,t.shadow.mapSize.height=this.shadowMapSize,t.shadow.camera.near=this.lightNear,t.shadow.camera.far=this.lightFar,t.shadow.bias=this.shadowBias,this.parent.add(t),this.parent.add(t.target),this.lights.push(t)}}initCascades(){const t=this.camera;t.updateProjectionMatrix(),this.mainFrustum.setFromProjectionMatrix(t.projectionMatrix,this.maxFar),this.mainFrustum.split(this.breaks,this.frustums)}updateShadowBounds(){const t=this.frustums;for(let e=0;e<t.length;e++){const t=this.lights[e].shadow.camera,n=this.frustums[e],i=n.vertices.near,s=n.vertices.far,r=s[0];let o;o=r.distanceTo(s[2])>r.distanceTo(i[2])?s[2]:i[2];let a=r.distanceTo(o);if(this.fade){const t=this.camera,e=Math.max(t.far,this.maxFar),i=n.vertices.far[0].z/(e-t.near);a+=.25*Math.pow(i,2)*(e-t.near)}t.left=-a/2,t.right=a/2,t.top=a/2,t.bottom=-a/2,t.updateProjectionMatrix()}}getBreaks(){const t=this.camera,e=Math.min(t.far,this.maxFar);switch(this.breaks.length=0,this.mode){case"uniform":n(this.cascades,t.near,e,this.breaks);break;case"logarithmic":i(this.cascades,t.near,e,this.breaks);break;case"practical":!function(t,e,s,r,o){Ge.length=0,Ke.length=0,i(t,e,s,Ke),n(t,e,s,Ge);for(let n=1;n<t;n++)o.push(X.lerp(Ge[n-1],Ke[n-1],.5));o.push(1)}(this.cascades,t.near,e,0,this.breaks);break;case"custom":this.customSplitsCallback,this.customSplitsCallback(this.cascades,t.near,e,this.breaks)}function n(t,e,n,i){for(let s=1;s<t;s++)i.push((e+(n-e)*s/t)/n);i.push(1)}function i(t,e,n,i){for(let s=1;s<t;s++)i.push(e*(n/e)**(s/t)/n);i.push(1)}}update(){const t=this.camera,n=this.frustums;Ve.lookAt(new e,this.lightDirection,We),Xe.copy(Ve).invert();for(let e=0;e<n.length;e++){const i=this.lights[e],s=i.shadow.camera,r=(s.right-s.left)/this.shadowMapSize,o=(s.top-s.bottom)/this.shadowMapSize;He.multiplyMatrices(Xe,t.matrixWorld),n[e].toSpace(He,Be);const a=Be.vertices.near,c=Be.vertices.far;ze.makeEmpty();for(let t=0;t<4;t++)ze.expandByPoint(a[t]),ze.expandByPoint(c[t]);ze.getCenter(je),je.z=ze.max.z+this.lightMargin,je.x=Math.floor(je.x/r)*r,je.y=Math.floor(je.y/o)*o,je.applyMatrix4(Ve),i.position.copy(je),i.target.position.copy(je),i.target.position.x+=this.lightDirection.x,i.target.position.y+=this.lightDirection.y,i.target.position.z+=this.lightDirection.z}}injectInclude(){Lt.lights_fragment_begin=Ue.lights_fragment_begin,Lt.lights_pars_begin=Ue.lights_pars_begin}setupMaterial(t){t.defines=t.defines||{},t.defines.USE_CSM=1,t.defines.CSM_CASCADES=this.cascades,this.fade&&(t.defines.CSM_FADE="");const e=[],n=this,i=this.shaders;t.onBeforeCompile=function(s){const r=Math.min(n.camera.far,n.maxFar);n.getExtendedBreaks(e),s.uniforms.CSM_cascades={value:e},s.uniforms.cameraNear={value:n.camera.near},s.uniforms.shadowFar={value:r},i.set(t,s)},i.set(t,null)}updateUniforms(){const t=Math.min(this.camera.far,this.maxFar);this.shaders.forEach((function(e,n){if(null!==e){const n=e.uniforms;this.getExtendedBreaks(n.CSM_cascades.value),n.cameraNear.value=this.camera.near,n.shadowFar.value=t}!this.fade&&"CSM_FADE"in n.defines?(delete n.defines.CSM_FADE,n.needsUpdate=!0):this.fade&&!("CSM_FADE"in n.defines)&&(n.defines.CSM_FADE="",n.needsUpdate=!0)}),this)}getExtendedBreaks(t){for(;t.length<this.breaks.length;)t.push(new o);t.length=this.breaks.length;for(let e=0;e<this.cascades;e++){const n=this.breaks[e],i=this.breaks[e-1]||0;t[e].x=i,t[e].y=n}}updateFrustums(){this.getBreaks(),this.initCascades(),this.updateShadowBounds(),this.updateUniforms()}remove(){for(let t=0;t<this.lights.length;t++)this.parent.remove(this.lights[t].target),this.parent.remove(this.lights[t])}dispose(){const t=this.shaders;t.forEach((function(t,e){delete e.onBeforeCompile,delete e.defines.USE_CSM,delete e.defines.CSM_CASCADES,delete e.defines.CSM_FADE,null!==t&&(delete t.uniforms.CSM_cascades,delete t.uniforms.cameraNear,delete t.uniforms.shadowFar),e.needsUpdate=!0})),t.clear()}}class qe extends K{constructor(t){super(),this.csm=t,this.displayFrustum=!0,this.displayPlanes=!0,this.displayShadowBounds=!0;const e=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),n=new Float32Array(24),i=new a;i.setIndex(new c(e,1)),i.setAttribute("position",new c(n,3,!1));const s=new B(i,new O);this.add(s),this.frustumLines=s,this.cascadeLines=[],this.cascadePlanes=[],this.shadowLines=[]}updateVisibility(){const t=this.displayFrustum,e=this.displayPlanes,n=this.displayShadowBounds,i=this.frustumLines,s=this.cascadeLines,r=this.cascadePlanes,o=this.shadowLines;for(let a=0,c=s.length;a<c;a++){const i=s[a],c=r[a],l=o[a];i.visible=t,c.visible=t&&e,l.visible=n}i.visible=t}update(){const t=this.csm,e=t.camera,n=t.cascades,i=t.mainFrustum,s=t.frustums,r=t.lights,o=this.frustumLines.geometry.getAttribute("position"),a=this.cascadeLines,c=this.cascadePlanes,l=this.shadowLines;for(this.position.copy(e.position),this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.updateMatrixWorld(!0);a.length>n;)this.remove(a.pop()),this.remove(c.pop()),this.remove(l.pop());for(;a.length<n;){const t=new Et(new ht,16777215),e=new A({transparent:!0,opacity:.1,depthWrite:!1,side:k}),n=new H(new Mt,e),i=new K,s=new Et(new ht,16776960);i.add(s),this.add(t),this.add(n),this.add(i),a.push(t),c.push(n),l.push(i)}for(let d=0;d<n;d++){const t=s[d],e=r[d].shadow.camera,n=t.vertices.far,i=a[d],o=c[d],h=l[d],u=h.children[0];i.box.min.copy(n[2]),i.box.max.copy(n[0]),i.box.max.z+=1e-4,o.position.addVectors(n[0],n[2]),o.position.multiplyScalar(.5),o.scale.subVectors(n[0],n[2]),o.scale.z=1e-4,this.remove(h),h.position.copy(e.position),h.quaternion.copy(e.quaternion),h.scale.copy(e.scale),h.updateMatrixWorld(!0),this.attach(h),u.box.min.set(e.bottom,e.left,-e.far),u.box.max.set(e.top,e.right,-e.near)}const h=i.vertices.near,u=i.vertices.far;o.setXYZ(0,u[0].x,u[0].y,u[0].z),o.setXYZ(1,u[3].x,u[3].y,u[3].z),o.setXYZ(2,u[2].x,u[2].y,u[2].z),o.setXYZ(3,u[1].x,u[1].y,u[1].z),o.setXYZ(4,h[0].x,h[0].y,h[0].z),o.setXYZ(5,h[3].x,h[3].y,h[3].z),o.setXYZ(6,h[2].x,h[2].y,h[2].z),o.setXYZ(7,h[1].x,h[1].y,h[1].z),o.needsUpdate=!0}dispose(){const t=this.frustumLines,e=this.cascadeLines,n=this.cascadePlanes,i=this.shadowLines;t.geometry.dispose(),t.material.dispose();const s=this.csm.cascades;for(let r=0;r<s;r++){const t=e[r],s=n[r],o=i[r].children[0];t.dispose(),s.geometry.dispose(),s.material.dispose(),o.dispose()}}}class Ze{static fromCubeTexture(t){let n=0;const i=new e,s=new e,r=new f,o=[0,0,0,0,0,0,0,0,0],a=new Rt,c=a.coefficients;for(let e=0;e<6;e++){const a=t.image[e],l=a.width,h=a.height,u=document.createElement("canvas");u.width=l,u.height=h;const d=u.getContext("2d");d.drawImage(a,0,0,l,h);const p=d.getImageData(0,0,l,h),m=p.data,f=p.width,g=2/f;for(let v=0,_=m.length;v<_;v+=4){r.setRGB(m[v]/255,m[v+1]/255,m[v+2]/255),Qe(r,t.encoding);const a=v/4,l=(a%f+.5)*g-1,h=1-(Math.floor(a/f)+.5)*g;switch(e){case 0:i.set(-1,h,-l);break;case 1:i.set(1,h,l);break;case 2:i.set(-l,1,-h);break;case 3:i.set(-l,-1,h);break;case 4:i.set(-l,h,1);break;case 5:i.set(l,h,-1)}const u=i.lengthSq(),d=4/(Math.sqrt(u)*u);n+=d,s.copy(i).normalize(),Rt.getBasisAt(s,o);for(let t=0;t<9;t++)c[t].x+=o[t]*r.r*d,c[t].y+=o[t]*r.g*d,c[t].z+=o[t]*r.b*d}}const l=4*Math.PI/n;for(let e=0;e<9;e++)c[e].x*=l,c[e].y*=l,c[e].z*=l;return new It(a)}static fromCubeRenderTarget(t,n){let i=0;const s=new e,r=new e,o=new f,a=[0,0,0,0,0,0,0,0,0],c=new Rt,l=c.coefficients;for(let e=0;e<6;e++){const c=n.width,h=new Uint8Array(c*c*4);t.readRenderTargetPixels(n,0,0,c,c,h,e);const u=2/c;for(let t=0,d=h.length;t<d;t+=4){o.setRGB(h[t]/255,h[t+1]/255,h[t+2]/255),Qe(o,n.texture.encoding);const d=t/4,p=(d%c+.5)*u-1,m=1-(Math.floor(d/c)+.5)*u;switch(e){case 0:s.set(1,m,-p);break;case 1:s.set(-1,m,p);break;case 2:s.set(p,1,-m);break;case 3:s.set(p,-1,m);break;case 4:s.set(p,m,1);break;case 5:s.set(-p,m,-1)}const f=s.lengthSq(),g=4/(Math.sqrt(f)*f);i+=g,r.copy(s).normalize(),Rt.getBasisAt(r,a);for(let t=0;t<9;t++)l[t].x+=a[t]*o.r*g,l[t].y+=a[t]*o.g*g,l[t].z+=a[t]*o.b*g}}const h=4*Math.PI/i;for(let e=0;e<9;e++)l[e].x*=h,l[e].y*=h,l[e].z*=h;return new It(c)}}function Qe(t,e){if(e===w)t.convertSRGBToLinear();return t}export{Ye as C,Gt as G,Pe as L,Ht as O,Oe as S,Nt as T,Ne as W,De as a,qe as b,Ze as c,Bt as m};
